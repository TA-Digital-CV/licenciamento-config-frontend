# PR01.03-BE-LIC-Dossier Tipo Licença - Entidades

## 1. Visão Geral

Este documento especifica a implementação do módulo de **Gestão de Entidades** para o Sistema de Licenciamento de Cabo Verde. O módulo é responsável pela gestão das entidades que participam nos processos de licenciamento, incluindo entidades de decisão, parecer e vistoria, bem como a gestão dos seus pontos focais.

### 1.1 Objetivos

* Normalizar o modelo de dados da tabela `GLIC_T_ENTIDADE` para `T_ENTITY`

* Implementar arquitetura DDD para gestão de entidades

* Fornecer APIs REST para CRUD de entidades com filtros avançados

* Integrar com sistema de organizações globais (REDGLOBAL.GLB\_T\_ORGANIZATION)

* Garantir validações robustas e integridade referencial

* Suportar múltiplos tipos de entidade parametrizáveis

## 2. Modelo de Dados Normalizado

### 2.1 Diagrama ER

```mermaid
erDiagram
    T_LICENSE_TYPE ||--o{ T_ENTITY : "has entities"
    T_ENTITY ||--o{ T_ENTITY_CONTACT : "has contacts"
    T_ENTITY {
        uuid id PK
        uuid license_type_id_fk FK
        uuid organization_id_fk FK
        varchar entity_name
        varchar entity_type
        varchar status
        timestamp created_at
        timestamp updated_at
        varchar created_by
        varchar updated_by
    }
    
    T_ENTITY_CONTACT {
        uuid id PK
        uuid entity_id_fk FK
        varchar contact_name
        varchar phone
        varchar email
        boolean is_primary
        varchar status
        timestamp created_at
        timestamp updated_at
        varchar created_by
        varchar updated_by
    }
    
    T_LICENSE_TYPE {
        uuid id PK
        varchar name
        varchar description
        uuid sector_id_fk FK
        boolean simplified_regime
        varchar regime
        boolean active
        timestamp created_at
        timestamp updated_at
    }
    
    T_OPTIONS {
        uuid id PK
        varchar ccode
        varchar ckey
        varchar cvalue
        varchar locale
        integer sort_order
        boolean active
        text description
        timestamp created_at
        timestamp updated_at
    }
```

### 2.2 Definição da Tabela T\_ENTITY

```sql
CREATE TABLE t_entity (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_type_id_fk UUID NOT NULL,
    organization_id_fk UUID,
    entity_name VARCHAR(255) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    
    CONSTRAINT fk_entity_license_type 
        FOREIGN KEY (license_type_id_fk) REFERENCES t_license_type(id) ON DELETE CASCADE,
    CONSTRAINT chk_entity_name_not_empty 
        CHECK (LENGTH(TRIM(entity_name)) > 0),
    CONSTRAINT chk_entity_type_valid 
        CHECK (entity_type IN ('DECISAO', 'PARECER', 'VISTORIA'))
);
```

### 2.3 Definição da Tabela T\_ENTITY\_CONTACT

```sql
CREATE TABLE t_entity_contact (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_id_fk UUID NOT NULL,
    contact_name VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    email VARCHAR(255),
    is_primary BOOLEAN NOT NULL DEFAULT false,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    
    CONSTRAINT fk_entity_contact_entity 
        FOREIGN KEY (entity_id_fk) REFERENCES t_entity(id) ON DELETE CASCADE,
    CONSTRAINT chk_contact_name_not_empty 
        CHECK (LENGTH(TRIM(contact_name)) > 0),
    CONSTRAINT chk_email_format 
        CHECK (email IS NULL OR email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);
```

### 2.4 Índices

```sql
-- Índice principal para consultas por tipo de licença
CREATE INDEX idx_entity_license_type ON t_entity(license_type_id_fk);

-- Índice para consultas por tipo de entidade
CREATE INDEX idx_entity_type ON t_entity(entity_type);

-- Índice para consultas por status
CREATE INDEX idx_entity_status ON t_entity(status) WHERE status = 'ACTIVE';

-- Índice para auditoria
CREATE INDEX idx_entity_created_at ON t_entity(created_at DESC);

-- Índice composto para consultas filtradas
CREATE INDEX idx_entity_type_status ON t_entity(license_type_id_fk, entity_type, status);

-- Índice para busca textual por nome
CREATE INDEX idx_entity_name_search ON t_entity USING gin(to_tsvector('portuguese', entity_name));

-- Índices para tabela de contatos
CREATE INDEX idx_entity_contact_entity ON t_entity_contact(entity_id_fk);
CREATE INDEX idx_entity_contact_primary ON t_entity_contact(entity_id_fk, is_primary) WHERE is_primary = true;
CREATE INDEX idx_entity_contact_email ON t_entity_contact(email) WHERE email IS NOT NULL;
```

## 3. Arquitetura DDD

### 3.1 Domain Layer

#### 3.1.1 Aggregate Root: Entity

```java
@Entity
@Table(name = "t_entity")
public class LicenseEntity {
    @Id
    private EntityId id;
    
    @Column(name = "license_type_id_fk", nullable = false)
    private LicenseTypeId licenseTypeId;
    
    @Column(name = "organization_id_fk")
    private OrganizationId organizationId;
    
    @Column(name = "entity_name", nullable = false)
    private String entityName;
    
    @Column(name = "entity_type", nullable = false)
    private String entityType;
    
    @Column(name = "status", nullable = false)
    private String status;
    
    @OneToMany(mappedBy = "entityId", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<EntityContact> contacts = new ArrayList<>();
    
    // Campos de auditoria
    @Column(name = "created_at", nullable = false)
    private Instant createdAt;
    
    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;
    
    @Column(name = "created_by", nullable = false)
    private String createdBy;
    
    @Column(name = "updated_by", nullable = false)
    private String updatedBy;
    
    // Métodos de negócio
    public static LicenseEntity create(
            LicenseTypeId licenseTypeId,
            String entityName,
            String entityType,
            OrganizationId organizationId,
            String createdBy,
            EntityType entityTypeService) {
        
        validateCreationParameters(licenseTypeId, entityName, entityType, createdBy, entityTypeService);
        
        return new LicenseEntity(
            EntityId.generate(),
            licenseTypeId,
            organizationId,
            entityName.trim(),
            entityType,
            "ACTIVE",
            createdBy
        );
    }
    
    public void updateEntityInfo(
            String entityName,
            String entityType,
            OrganizationId organizationId,
            String updatedBy,
            EntityType entityTypeService) {
        
        validateUpdateParameters(entityName, entityType, updatedBy, entityTypeService);
        
        this.entityName = entityName.trim();
        this.entityType = entityType;
        this.organizationId = organizationId;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }
    
    public void addContact(
            String contactName,
            String phone,
            String email,
            boolean isPrimary,
            String createdBy) {
        
        validateContactParameters(contactName, email);
        
        if (isPrimary) {
            // Remove primary flag from existing contacts
            contacts.forEach(contact -> contact.setPrimary(false));
        }
        
        EntityContact contact = EntityContact.create(
            this.id,
            contactName,
            phone,
            email,
            isPrimary,
            createdBy
        );
        
        this.contacts.add(contact);
        this.updatedAt = Instant.now();
        this.updatedBy = createdBy;
    }
    
    public void removeContact(EntityContactId contactId, String updatedBy) {
        contacts.removeIf(contact -> contact.getId().equals(contactId));
        this.updatedAt = Instant.now();
        this.updatedBy = updatedBy;
    }
    
    public void deactivate(String updatedBy) {
        this.status = "INACTIVE";
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }
    
    public void activate(String updatedBy) {
        this.status = "ACTIVE";
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }
    
    // Métodos de validação
    private static void validateCreationParameters(
            LicenseTypeId licenseTypeId,
            String entityName,
            String entityType,
            String createdBy,
            EntityType entityTypeService) {
        
        if (licenseTypeId == null) {
            throw new IllegalArgumentException("License type ID cannot be null");
        }
        
        if (entityName == null || entityName.trim().isEmpty()) {
            throw new IllegalArgumentException("Entity name cannot be null or empty");
        }
        
        if (entityName.trim().length() > 255) {
            throw new IllegalArgumentException("Entity name cannot exceed 255 characters");
        }
        
        if (!entityTypeService.isValidEntityType(entityType)) {
            throw new IllegalArgumentException("Invalid entity type: " + entityType);
        }
        
        if (createdBy == null || createdBy.trim().isEmpty()) {
            throw new IllegalArgumentException("Created by cannot be null or empty");
        }
    }
    
    private static void validateUpdateParameters(
            String entityName,
            String entityType,
            String updatedBy,
            EntityType entityTypeService) {
        
        if (entityName == null || entityName.trim().isEmpty()) {
            throw new IllegalArgumentException("Entity name cannot be null or empty");
        }
        
        if (entityName.trim().length() > 255) {
            throw new IllegalArgumentException("Entity name cannot exceed 255 characters");
        }
        
        if (!entityTypeService.isValidEntityType(entityType)) {
            throw new IllegalArgumentException("Invalid entity type: " + entityType);
        }
        
        if (updatedBy == null || updatedBy.trim().isEmpty()) {
            throw new IllegalArgumentException("Updated by cannot be null or empty");
        }
    }
    
    private static void validateContactParameters(String contactName, String email) {
        if (contactName == null || contactName.trim().isEmpty()) {
            throw new IllegalArgumentException("Contact name cannot be null or empty");
        }
        
        if (contactName.trim().length() > 255) {
            throw new IllegalArgumentException("Contact name cannot exceed 255 characters");
        }
        
        if (email != null && !email.matches("^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
            throw new IllegalArgumentException("Invalid email format");
        }
    }
    
    // Getters
    public EntityId getId() { return id; }
    public LicenseTypeId getLicenseTypeId() { return licenseTypeId; }
    public OrganizationId getOrganizationId() { return organizationId; }
    public String getEntityName() { return entityName; }
    public String getEntityType() { return entityType; }
    public String getStatus() { return status; }
    public List<EntityContact> getContacts() { return Collections.unmodifiableList(contacts); }
    public Instant getCreatedAt() { return createdAt; }
    public Instant getUpdatedAt() { return updatedAt; }
    public String getCreatedBy() { return createdBy; }
    public String getUpdatedBy() { return updatedBy; }
}
```

#### 3.1.2 Entity: EntityContact

```java
@Entity
@Table(name = "t_entity_contact")
public class EntityContact {
    @Id
    private EntityContactId id;
    
    @Column(name = "entity_id_fk", nullable = false)
    private EntityId entityId;
    
    @Column(name = "contact_name", nullable = false)
    private String contactName;
    
    @Column(name = "phone")
    private String phone;
    
    @Column(name = "email")
    private String email;
    
    @Column(name = "is_primary", nullable = false)
    private boolean isPrimary;
    
    @Column(name = "status", nullable = false)
    private String status;
    
    // Campos de auditoria
    @Column(name = "created_at", nullable = false)
    private Instant createdAt;
    
    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;
    
    @Column(name = "created_by", nullable = false)
    private String createdBy;
    
    @Column(name = "updated_by", nullable = false)
    private String updatedBy;
    
    public static EntityContact create(
            EntityId entityId,
            String contactName,
            String phone,
            String email,
            boolean isPrimary,
            String createdBy) {
        
        return new EntityContact(
            EntityContactId.generate(),
            entityId,
            contactName.trim(),
            phone != null ? phone.trim() : null,
            email != null ? email.trim() : null,
            isPrimary,
            "ACTIVE",
            createdBy
        );
    }
    
    public void updateContactInfo(
            String contactName,
            String phone,
            String email,
            String updatedBy) {
        
        this.contactName = contactName.trim();
        this.phone = phone != null ? phone.trim() : null;
        this.email = email != null ? email.trim() : null;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }
    
    public void setPrimary(boolean isPrimary) {
        this.isPrimary = isPrimary;
        this.updatedAt = Instant.now();
    }
    
    // Getters
    public EntityContactId getId() { return id; }
    public EntityId getEntityId() { return entityId; }
    public String getContactName() { return contactName; }
    public String getPhone() { return phone; }
    public String getEmail() { return email; }
    public boolean isPrimary() { return isPrimary; }
    public String getStatus() { return status; }
    public Instant getCreatedAt() { return createdAt; }
    public Instant getUpdatedAt() { return updatedAt; }
    public String getCreatedBy() { return createdBy; }
    public String getUpdatedBy() { return updatedBy; }
}
```

#### 3.1.3 Value Objects

```java
@Embeddable
public class EntityId {
    @Column(name = "id")
    private UUID value;
    
    public static EntityId generate() {
        return new EntityId(UUID.randomUUID());
    }
    
    public static EntityId of(UUID value) {
        return new EntityId(value);
    }
    
    public static EntityId of(String value) {
        return new EntityId(UUID.fromString(value));
    }
    
    public UUID getValue() { return value; }
}

@Embeddable
public class EntityContactId {
    @Column(name = "id")
    private UUID value;
    
    public static EntityContactId generate() {
        return new EntityContactId(UUID.randomUUID());
    }
    
    public static EntityContactId of(UUID value) {
        return new EntityContactId(value);
    }
    
    public static EntityContactId of(String value) {
        return new EntityContactId(UUID.fromString(value));
    }
    
    public UUID getValue() { return value; }
}
```

#### 3.1.4 Domain Services

```java
@Component
public class EntityType {
    private final OptionsRepository optionsRepository;
    
    public EntityType(OptionsRepository optionsRepository) {
        this.optionsRepository = optionsRepository;
    }
    
    public boolean isValidEntityType(String entityType) {
        if (entityType == null || entityType.trim().isEmpty()) {
            return false;
        }
        
        List<String> validTypes = Arrays.asList("DECISAO", "PARECER", "VISTORIA");
        return validTypes.contains(entityType.toUpperCase());
    }
    
    public List<String> getAvailableEntityTypes() {
        return optionsRepository.findByCcodeAndActiveTrue("ENTITY_TYPE")
                .stream()
                .map(option -> option.getCvalue())
                .collect(Collectors.toList());
    }
}
```

### 3.2 Application Layer

#### 3.2.1 Application Services

```java
@Service
@Transactional
public class EntityApplicationService {
    private final EntityRepository entityRepository;
    private final LicenseTypeRepository licenseTypeRepository;
    private final OrganizationService organizationService;
    private final EntityType entityTypeService;
    
    public EntityApplicationService(
            EntityRepository entityRepository,
            LicenseTypeRepository licenseTypeRepository,
            OrganizationService organizationService,
            EntityType entityTypeService) {
        this.entityRepository = entityRepository;
        this.licenseTypeRepository = licenseTypeRepository;
        this.organizationService = organizationService;
        this.entityTypeService = entityTypeService;
    }
    
    public EntityId createEntity(CreateEntityCommand command) {
        // Validar se o tipo de licença existe
        if (!licenseTypeRepository.existsById(command.getLicenseTypeId())) {
            throw new LicenseTypeNotFoundException(command.getLicenseTypeId());
        }
        
        // Buscar ou criar organização se fornecida
        OrganizationId organizationId = null;
        if (command.getOrganizationName() != null) {
            organizationId = organizationService.findOrCreateOrganization(command.getOrganizationName());
        }
        
        LicenseEntity entity = LicenseEntity.create(
            command.getLicenseTypeId(),
            command.getEntityName(),
            command.getEntityType(),
            organizationId,
            command.getCreatedBy(),
            entityTypeService
        );
        
        // Adicionar contatos se fornecidos
        if (command.getContacts() != null && !command.getContacts().isEmpty()) {
            for (CreateContactCommand contactCommand : command.getContacts()) {
                entity.addContact(
                    contactCommand.getContactName(),
                    contactCommand.getPhone(),
                    contactCommand.getEmail(),
                    contactCommand.isPrimary(),
                    command.getCreatedBy()
                );
            }
        }
        
        entityRepository.save(entity);
        return entity.getId();
    }
    
    public void updateEntity(UpdateEntityCommand command) {
        LicenseEntity entity = entityRepository.findById(command.getEntityId())
                .orElseThrow(() -> new EntityNotFoundException(command.getEntityId()));
        
        // Buscar ou criar organização se fornecida
        OrganizationId organizationId = null;
        if (command.getOrganizationName() != null) {
            organizationId = organizationService.findOrCreateOrganization(command.getOrganizationName());
        }
        
        entity.updateEntityInfo(
            command.getEntityName(),
            command.getEntityType(),
            organizationId,
            command.getUpdatedBy(),
            entityTypeService
        );
        
        entityRepository.save(entity);
    }
    
    public void addEntityContact(AddEntityContactCommand command) {
        LicenseEntity entity = entityRepository.findById(command.getEntityId())
                .orElseThrow(() -> new EntityNotFoundException(command.getEntityId()));
        
        entity.addContact(
            command.getContactName(),
            command.getPhone(),
            command.getEmail(),
            command.isPrimary(),
            command.getCreatedBy()
        );
        
        entityRepository.save(entity);
    }
    
    public void removeEntityContact(RemoveEntityContactCommand command) {
        LicenseEntity entity = entityRepository.findById(command.getEntityId())
                .orElseThrow(() -> new EntityNotFoundException(command.getEntityId()));
        
        entity.removeContact(command.getContactId(), command.getUpdatedBy());
        entityRepository.save(entity);
    }
    
    public void deleteEntity(DeleteEntityCommand command) {
        LicenseEntity entity = entityRepository.findById(command.getEntityId())
                .orElseThrow(() -> new EntityNotFoundException(command.getEntityId()));
        
        entity.deactivate(command.getUpdatedBy());
        entityRepository.save(entity);
    }
    
    public void deleteEntities(DeleteEntitiesCommand command) {
        List<LicenseEntity> entities = entityRepository.findAllById(command.getEntityIds());
        
        if (entities.size() != command.getEntityIds().size()) {
            throw new IllegalArgumentException("Some entities were not found");
        }
        
        entities.forEach(entity -> entity.deactivate(command.getUpdatedBy()));
        entityRepository.saveAll(entities);
    }
    
    @Transactional(readOnly = true)
    public EntityDetailResponse getEntityDetail(EntityId entityId) {
        LicenseEntity entity = entityRepository.findById(entityId)
                .orElseThrow(() -> new EntityNotFoundException(entityId));
        
        return EntityDetailResponse.from(entity);
    }
    
    @Transactional(readOnly = true)
    public PagedResult<EntityListResponse> searchEntities(SearchEntitiesQuery query) {
        return entityRepository.searchEntities(query);
    }
}
```

#### 3.2.2 Commands

```java
public class CreateEntityCommand {
    private final LicenseTypeId licenseTypeId;
    private final String entityName;
    private final String entityType;
    private final String organizationName;
    private final List<CreateContactCommand> contacts;
    private final String createdBy;
    
    // Constructor, getters
}

public class CreateContactCommand {
    private final String contactName;
    private final String phone;
    private final String email;
    private final boolean isPrimary;
    
    // Constructor, getters
}

public class UpdateEntityCommand {
    private final EntityId entityId;
    private final String entityName;
    private final String entityType;
    private final String organizationName;
    private final String updatedBy;
    
    // Constructor, getters
}

public class AddEntityContactCommand {
    private final EntityId entityId;
    private final String contactName;
    private final String phone;
    private final String email;
    private final boolean isPrimary;
    private final String createdBy;
    
    // Constructor, getters
}

public class RemoveEntityContactCommand {
    private final EntityId entityId;
    private final EntityContactId contactId;
    private final String updatedBy;
    
    // Constructor, getters
}

public class DeleteEntityCommand {
    private final EntityId entityId;
    private final String updatedBy;
    
    // Constructor, getters
}

public class DeleteEntitiesCommand {
    private final List<EntityId> entityIds;
    private final String updatedBy;
    
    // Constructor, getters
}
```

#### 3.2.3 Queries

```java
public class SearchEntitiesQuery {
    private final LicenseTypeId licenseTypeId;
    private final String entityType;
    private final String entityName;
    private final String status;
    private final int page;
    private final int size;
    private final String sortBy;
    private final String sortDirection;
    
    // Constructor, getters
}
```

#### 3.2.4 Response DTOs

```java
public class EntityListResponse {
    private final EntityId id;
    private final String entityName;
    private final String entityType;
    private final String organizationName;
    private final int contactCount;
    private final String status;
    private final Instant createdAt;
    private final String createdBy;
    
    public static EntityListResponse from(LicenseEntity entity, String organizationName) {
        return new EntityListResponse(
            entity.getId(),
            entity.getEntityName(),
            entity.getEntityType(),
            organizationName,
            entity.getContacts().size(),
            entity.getStatus(),
            entity.getCreatedAt(),
            entity.getCreatedBy()
        );
    }
    
    // Getters
}

public class EntityDetailResponse {
    private final EntityId id;
    private final LicenseTypeId licenseTypeId;
    private final String licenseTypeName;
    private final String entityName;
    private final String entityType;
    private final String organizationName;
    private final List<EntityContactResponse> contacts;
    private final String status;
    private final Instant createdAt;
    private final Instant updatedAt;
    private final String createdBy;
    private final String updatedBy;
    
    public static EntityDetailResponse from(LicenseEntity entity) {
        List<EntityContactResponse> contacts = entity.getContacts().stream()
                .map(EntityContactResponse::from)
                .collect(Collectors.toList());
        
        return new EntityDetailResponse(
            entity.getId(),
            entity.getLicenseTypeId(),
            null, // será preenchido pelo service
            entity.getEntityName(),
            entity.getEntityType(),
            null, // será preenchido pelo service
            contacts,
            entity.getStatus(),
            entity.getCreatedAt(),
            entity.getUpdatedAt(),
            entity.getCreatedBy(),
            entity.getUpdatedBy()
        );
    }
    
    // Getters
}

public class EntityContactResponse {
    private final EntityContactId id;
    private final String contactName;
    private final String phone;
    private final String email;
    private final boolean isPrimary;
    private final String status;
    
    public static EntityContactResponse from(EntityContact contact) {
        return new EntityContactResponse(
            contact.getId(),
            contact.getContactName(),
            contact.getPhone(),
            contact.getEmail(),
            contact.isPrimary(),
            contact.getStatus()
        );
    }
    
    // Getters
}
```

### 3.3 Infrastructure Layer

#### 3.3.1 Repository Implementation

```java
@Repository
public class JpaEntityRepository implements EntityRepository {
    private final EntityJpaRepository jpaRepository;
    private final EntityQueryRepository queryRepository;
    
    public JpaEntityRepository(
            EntityJpaRepository jpaRepository,
            EntityQueryRepository queryRepository) {
        this.jpaRepository = jpaRepository;
        this.queryRepository = queryRepository;
    }
    
    @Override
    public void save(LicenseEntity entity) {
        jpaRepository.save(entity);
    }
    
    @Override
    public Optional<LicenseEntity> findById(EntityId id) {
        return jpaRepository.findById(id.getValue());
    }
    
    @Override
    public List<LicenseEntity> findAllById(List<EntityId> ids) {
        List<UUID> uuids = ids.stream()
                .map(EntityId::getValue)
                .collect(Collectors.toList());
        return jpaRepository.findAllById(uuids);
    }
    
    @Override
    public boolean existsById(EntityId id) {
        return jpaRepository.existsById(id.getValue());
    }
    
    @Override
    public PagedResult<EntityListResponse> searchEntities(SearchEntitiesQuery query) {
        return queryRepository.searchEntities(query);
    }
    
    @Override
    public void saveAll(List<LicenseEntity> entities) {
        jpaRepository.saveAll(entities);
    }
}

interface EntityJpaRepository extends JpaRepository<LicenseEntity, UUID> {
    List<LicenseEntity> findByLicenseTypeIdAndStatusOrderByEntityNameAsc(
            LicenseTypeId licenseTypeId, String status);
    
    List<LicenseEntity> findByEntityTypeAndStatusOrderByEntityNameAsc(
            String entityType, String status);
    
    @Query("SELECT e FROM LicenseEntity e WHERE e.entityName ILIKE %:name% AND e.status = :status")
    List<LicenseEntity> findByEntityNameContainingIgnoreCaseAndStatus(
            @Param("name") String name, @Param("status") String status);
}
```

#### 3.3.2 Query Repository

```java
@Repository
public class EntityQueryRepository {
    private final EntityManager entityManager;
    
    public EntityQueryRepository(EntityManager entityManager) {
        this.entityManager = entityManager;
    }
    
    public PagedResult<EntityListResponse> searchEntities(SearchEntitiesQuery query) {
        StringBuilder jpql = new StringBuilder(
            "SELECT e FROM LicenseEntity e WHERE e.status = 'ACTIVE'"
        );
        
        Map<String, Object> parameters = new HashMap<>();
        
        if (query.getLicenseTypeId() != null) {
            jpql.append(" AND e.licenseTypeId = :licenseTypeId");
            parameters.put("licenseTypeId", query.getLicenseTypeId());
        }
        
        if (query.getEntityType() != null && !query.getEntityType().trim().isEmpty()) {
            jpql.append(" AND e.entityType = :entityType");
            parameters.put("entityType", query.getEntityType());
        }
        
        if (query.getEntityName() != null && !query.getEntityName().trim().isEmpty()) {
            jpql.append(" AND LOWER(e.entityName) LIKE LOWER(:entityName)");
            parameters.put("entityName", "%" + query.getEntityName().trim() + "%");
        }
        
        if (query.getStatus() != null && !query.getStatus().trim().isEmpty()) {
            jpql.append(" AND e.status = :status");
            parameters.put("status", query.getStatus());
        }
        
        // Ordenação
        String sortBy = query.getSortBy() != null ? query.getSortBy() : "entityName";
        String sortDirection = "DESC".equalsIgnoreCase(query.getSortDirection()) ? "DESC" : "ASC";
        jpql.append(" ORDER BY e.").append(sortBy).append(" ").append(sortDirection);
        
        // Query para contagem
        String countJpql = jpql.toString().replace("SELECT e FROM", "SELECT COUNT(e) FROM")
                .replaceAll("ORDER BY.*", "");
        
        TypedQuery<Long> countQuery = entityManager.createQuery(countJpql, Long.class);
        parameters.forEach(countQuery::setParameter);
        long totalElements = countQuery.getSingleResult();
        
        // Query para dados
        TypedQuery<LicenseEntity> dataQuery = entityManager.createQuery(jpql.toString(), LicenseEntity.class);
        parameters.forEach(dataQuery::setParameter);
        dataQuery.setFirstResult(query.getPage() * query.getSize());
        dataQuery.setMaxResults(query.getSize());
        
        List<LicenseEntity> entities = dataQuery.getResultList();
        List<EntityListResponse> responses = entities.stream()
                .map(entity -> EntityListResponse.from(entity, getOrganizationName(entity.getOrganizationId())))
                .collect(Collectors.toList());
        
        return new PagedResult<>(
            responses,
            query.getPage(),
            query.getSize(),
            totalElements
        );
    }
    
    private String getOrganizationName(OrganizationId organizationId) {
        if (organizationId == null) {
            return null;
        }
        
        // Implementar busca do nome da organização
        // Pode ser através de um service ou query direta
        return "Organization Name"; // Placeholder
    }
}
```

## 4. Documentação da API REST

### 4.1 Endpoints Disponíveis

#### Base URL

```
http://localhost:8080/api/v1
```

### 4.2 Lista de Entidades

**Endpoint:** `GET /entities`

**Descrição:** Retorna lista paginada de entidades com filtros opcionais

**Parâmetros de Query:**

* `licenseTypeId` (UUID, opcional): ID do tipo de licença para filtrar

* `entityType` (string, opcional): Tipo de entidade (DECISAO, PARECER, VISTORIA)

* `status` (string, opcional): Status da entidade (ACTIVE, INACTIVE)

* `page` (integer, opcional): Número da página (0-based, padrão: 0)

* `size` (integer, opcional): Tamanho da página (1-100, padrão: 20)

* `sort` (string, opcional): Campo para ordenação (entityName, createdAt, updatedAt)

* `direction` (string, opcional): Direção da ordenação (ASC, DESC)

**Exemplo de Request:**

```http
GET /api/v1/entities?licenseTypeId=123e4567-e89b-12d3-a456-426614174000&entityType=DECISAO&page=0&size=10&sort=entityName&direction=ASC
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Exemplo de Response (200 OK):**

```json
{
  "content": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
      "organizationId": "789e4567-e89b-12d3-a456-426614174000",
      "entityName": "Câmara Municipal de Praia",
      "entityType": "DECISAO",
      "status": "ACTIVE",
      "contacts": [
        {
          "id": "660e8400-e29b-41d4-a716-446655440000",
          "contactName": "João Silva",
          "phone": "+238 260 1234",
          "email": "joao.silva@cmpraia.cv",
          "isPrimary": true,
          "status": "ACTIVE"
        }
      ],
      "createdAt": "2024-01-15T10:30:00Z",
      "updatedAt": "2024-01-15T10:30:00Z",
      "createdBy": "admin",
      "updatedBy": "admin"
    }
  ],
  "pageable": {
    "sort": {
      "sorted": true,
      "unsorted": false,
      "empty": false
    },
    "pageNumber": 0,
    "pageSize": 10,
    "offset": 0,
    "paged": true,
    "unpaged": false
  },
  "totalElements": 25,
  "totalPages": 3,
  "last": false,
  "first": true,
  "numberOfElements": 10,
  "size": 10,
  "number": 0,
  "sort": {
    "sorted": true,
    "unsorted": false,
    "empty": false
  },
  "empty": false
}
```

### 4.3 Buscar Entidade por ID

**Endpoint:** `GET /entities/{id}`

**Descrição:** Retorna detalhes de uma entidade específica

**Parâmetros de Path:**

* `id` (UUID, obrigatório): ID da entidade

**Exemplo de Request:**

```http
GET /api/v1/entities/550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Exemplo de Response (200 OK):**

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
  "organizationId": "789e4567-e89b-12d3-a456-426614174000",
  "entityName": "Câmara Municipal de Praia",
  "entityType": "DECISAO",
  "status": "ACTIVE",
  "contacts": [
    {
      "id": "660e8400-e29b-41d4-a716-446655440000",
      "contactName": "João Silva",
      "phone": "+238 260 1234",
      "email": "joao.silva@cmpraia.cv",
      "isPrimary": true,
      "status": "ACTIVE"
    },
    {
      "id": "660e8400-e29b-41d4-a716-446655440003",
      "contactName": "Ana Rodrigues",
      "phone": "+238 260 4567",
      "email": "ana.rodrigues@cmpraia.cv",
      "isPrimary": false,
      "status": "ACTIVE"
    }
  ],
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-01-15T10:30:00Z",
  "createdBy": "admin",
  "updatedBy": "admin"
}
```

### 4.4 Criar Nova Entidade

**Endpoint:** `POST /entities`

**Descrição:** Cria uma nova entidade no sistema

**Exemplo de Request:**

```http
POST /api/v1/entities
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

{
  "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
  "organizationId": "789e4567-e89b-12d3-a456-426614174000",
  "entityName": "Instituto Nacional de Meteorologia",
  "entityType": "PARECER",
  "contacts": [
    {
      "contactName": "Carlos Mendes",
      "phone": "+238 260 7890",
      "email": "carlos.mendes@inmg.cv",
      "isPrimary": true
    }
  ]
}
```

**Exemplo de Response (201 Created):**

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440010",
  "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
  "organizationId": "789e4567-e89b-12d3-a456-426614174000",
  "entityName": "Instituto Nacional de Meteorologia",
  "entityType": "PARECER",
  "status": "ACTIVE",
  "contacts": [
    {
      "id": "660e8400-e29b-41d4-a716-446655440010",
      "contactName": "Carlos Mendes",
      "phone": "+238 260 7890",
      "email": "carlos.mendes@inmg.cv",
      "isPrimary": true,
      "status": "ACTIVE"
    }
  ],
  "createdAt": "2024-01-22T16:45:00Z",
  "updatedAt": "2024-01-22T16:45:00Z",
  "createdBy": "user456",
  "updatedBy": "user456"
}
```

### 4.5 Atualizar Entidade

**Endpoint:** `PUT /entities/{id}`

**Descrição:** Atualiza uma entidade existente

**Parâmetros de Path:**

* `id` (UUID, obrigatório): ID da entidade

**Exemplo de Request:**

```http
PUT /api/v1/entities/550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

{
  "organizationId": "789e4567-e89b-12d3-a456-426614174000",
  "entityName": "Câmara Municipal da Praia - Atualizada",
  "entityType": "DECISAO",
  "status": "ACTIVE",
  "contacts": [
    {
      "id": "660e8400-e29b-41d4-a716-446655440000",
      "contactName": "João Silva Santos",
      "phone": "+238 260 1234",
      "email": "joao.silva@cmpraia.cv",
      "isPrimary": true,
      "status": "ACTIVE"
    }
  ]
}
```

**Exemplo de Response (200 OK):**

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
  "organizationId": "789e4567-e89b-12d3-a456-426614174000",
  "entityName": "Câmara Municipal da Praia - Atualizada",
  "entityType": "DECISAO",
  "status": "ACTIVE",
  "contacts": [
    {
      "id": "660e8400-e29b-41d4-a716-446655440000",
      "contactName": "João Silva Santos",
      "phone": "+238 260 1234",
      "email": "joao.silva@cmpraia.cv",
      "isPrimary": true,
      "status": "ACTIVE"
    }
  ],
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-01-23T11:20:00Z",
  "createdBy": "admin",
  "updatedBy": "user789"
}
```

### 4.6 Remover Entidade

**Endpoint:** `DELETE /entities/{id}`

**Descrição:** Remove uma entidade do sistema (soft delete)

**Parâmetros de Path:**

* `id` (UUID, obrigatório): ID da entidade

**Exemplo de Request:**

```http
DELETE /api/v1/entities/550e8400-e29b-41d4-a716-446655440000
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Exemplo de Response (204 No Content):**

```http
HTTP/1.1 204 No Content
Date: Mon, 23 Jan 2024 12:00:00 GMT
Server: Apache/2.4.41
```

### 4.7 Códigos de Status HTTP

| Código | Descrição             | Quando Usar                                         |
| ------ | --------------------- | --------------------------------------------------- |
| 200    | OK                    | Operação realizada com sucesso (GET, PUT)           |
| 201    | Created               | Recurso criado com sucesso (POST)                   |
| 204    | No Content            | Recurso removido com sucesso (DELETE)               |
| 400    | Bad Request           | Dados de entrada inválidos ou parâmetros incorretos |
| 401    | Unauthorized          | Token de autenticação ausente ou inválido           |
| 403    | Forbidden             | Usuário não tem permissão para acessar o recurso    |
| 404    | Not Found             | Recurso não encontrado                              |
| 409    | Conflict              | Conflito de dados (ex: entidade já existe)          |
| 500    | Internal Server Error | Erro interno do servidor                            |

### 4.8 Headers Obrigatórios

**Para todas as requisições:**

* `Content-Type: application/json`

* `Authorization: Bearer {token}`

**Para respostas:**

* `Content-Type: application/json`

* `X-Request-ID: {uuid}` (para rastreamento)

### 4.9 Controller Implementation

```java
@RestController
@RequestMapping("/api/v1/entities")
@Validated
public class EntityController {
    private final EntityApplicationService entityService;
    
    public EntityController(EntityApplicationService entityService) {
        this.entityService = entityService;
    }
    
    @GetMapping
    public ResponseEntity<PagedResponse<EntityListResponse>> searchEntities(
            @RequestParam(required = false) String licenseTypeId,
            @RequestParam(required = false) String entityType,
            @RequestParam(required = false) String entityName,
            @RequestParam(required = false) String status,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "entityName") String sortBy,
            @RequestParam(defaultValue = "ASC") String sortDirection) {
        
        SearchEntitiesQuery query = new SearchEntitiesQuery(
            licenseTypeId != null ? LicenseTypeId.of(licenseTypeId) : null,
            entityType,
            entityName,
            status,
            page,
            size,
            sortBy,
            sortDirection
        );
        
        PagedResult<EntityListResponse> result = entityService.searchEntities(query);
        return ResponseEntity.ok(PagedResponse.from(result));
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<EntityDetailResponse> getEntityDetail(
            @PathVariable String id) {
        
        EntityDetailResponse response = entityService.getEntityDetail(EntityId.of(id));
        return ResponseEntity.ok(response);
    }
    
    @PostMapping
    public ResponseEntity<CreateEntityResponse> createEntity(
            @Valid @RequestBody CreateEntityRequest request,
            Authentication authentication) {
        
        CreateEntityCommand command = new CreateEntityCommand(
            LicenseTypeId.of(request.getLicenseTypeId()),
            request.getEntityName(),
            request.getEntityType(),
            request.getOrganizationName(),
            request.getContacts().stream()
                    .map(c -> new CreateContactCommand(
                        c.getContactName(),
                        c.getPhone(),
                        c.getEmail(),
                        c.isPrimary()))
                    .collect(Collectors.toList()),
            authentication.getName()
        );
        
        EntityId entityId = entityService.createEntity(command);
        
        CreateEntityResponse response = new CreateEntityResponse(entityId.getValue().toString());
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<Void> updateEntity(
            @PathVariable String id,
            @Valid @RequestBody UpdateEntityRequest request,
            Authentication authentication) {
        
        UpdateEntityCommand command = new UpdateEntityCommand(
            EntityId.of(id),
            request.getEntityName(),
            request.getEntityType(),
            request.getOrganizationName(),
            authentication.getName()
        );
        
        entityService.updateEntity(command);
        return ResponseEntity.ok().build();
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteEntity(
            @PathVariable String id,
            Authentication authentication) {
        
        DeleteEntityCommand command = new DeleteEntityCommand(
            EntityId.of(id),
            authentication.getName()
        );
        
        entityService.deleteEntity(command);
        return ResponseEntity.ok().build();
    }
}
```

### 4.2 Request/Response DTOs

```java
public class CreateEntityRequest {
    @NotBlank(message = "License type ID is required")
    private String licenseTypeId;
    
    @NotBlank(message = "Entity name is required")
    @Size(max = 255, message = "Entity name cannot exceed 255 characters")
    private String entityName;
    
    @NotBlank(message = "Entity type is required")
    private String entityType;
    
    private String organizationName;
    
    @Valid
    private List<CreateContactRequest> contacts = new ArrayList<>();
    
    // Getters and setters
}

public class CreateContactRequest {
    @NotBlank(message = "Contact name is required")
    @Size(max = 255, message = "Contact name cannot exceed 255 characters")
    private String contactName;
    
    @Size(max = 20, message = "Phone cannot exceed 20 characters")
    private String phone;
    
    @Email(message = "Invalid email format")
    @Size(max = 255, message = "Email cannot exceed 255 characters")
    private String email;
    
    private boolean isPrimary = false;
    
    // Getters and setters
}

public class UpdateEntityRequest {
    @NotBlank(message = "Entity name is required")
    @Size(max = 255, message = "Entity name cannot exceed 255 characters")
    private String entityName;
    
    @NotBlank(message = "Entity type is required")
    private String entityType;
    
    private String organizationName;
    
    // Getters and setters
}

public class AddEntityContactRequest {
    @NotBlank(message = "Contact name is required")
    @Size(max = 255, message = "Contact name cannot exceed 255 characters")
    private String contactName;
    
    @Size(max = 20, message = "Phone cannot exceed 20 characters")
    private String phone;
    
    @Email(message = "Invalid email format")
    @Size(max = 255, message = "Email cannot exceed 255 characters")
    private String email;
    
    private boolean isPrimary = false;
    
    // Getters and setters
}

public class DeleteEntitiesRequest {
    @NotEmpty(message = "Entity IDs list cannot be empty")
    private List<String> entityIds;
    
    // Getters and setters
}

public class CreateEntityResponse {
    private final String id;
    
    public CreateEntityResponse(String id) {
        this.id = id;
    }
    
    public String getId() { return id; }
}
```

### 4.3 Documentação OpenAPI

```java
@OpenAPIDefinition(
    info = @Info(
        title = "Entity Management API",
        version = "1.0",
        description = "API para gestão de entidades do sistema de licenciamento"
    )
)
@Tag(name = "Entities", description = "Operações relacionadas à gestão de entidades")
public class EntityApiDocumentation {
    
    @Operation(
        summary = "Listar entidades",
        description = "Retorna uma lista paginada de entidades com filtros opcionais"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Lista de entidades retornada com sucesso"),
        @ApiResponse(responseCode = "400", description = "Parâmetros de consulta inválidos"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<PagedResponse<EntityListResponse>> searchEntities(
            @Parameter(description = "ID do tipo de licença para filtrar") String licenseTypeId,
            @Parameter(description = "Tipo de entidade (DECISAO, PARECER, VISTORIA)") String entityType,
            @Parameter(description = "Nome da entidade para busca parcial") String entityName,
            @Parameter(description = "Status da entidade") String status,
            @Parameter(description = "Número da página (0-based)") int page,
            @Parameter(description = "Tamanho da página") int size,
            @Parameter(description = "Campo para ordenação") String sortBy,
            @Parameter(description = "Direção da ordenação (ASC/DESC)") String sortDirection) {
        return null; // Implementação no controller
    }
    
    @Operation(
        summary = "Obter detalhes da entidade",
        description = "Retorna os detalhes completos de uma entidade específica"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Detalhes da entidade retornados com sucesso"),
        @ApiResponse(responseCode = "404", description = "Entidade não encontrada"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<EntityDetailResponse> getEntityDetail(
            @Parameter(description = "ID da entidade", required = true) String id) {
        return null; // Implementação no controller
    }
    
    @Operation(
        summary = "Criar nova entidade",
        description = "Cria uma nova entidade no sistema"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "201", description = "Entidade criada com sucesso"),
        @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos"),
        @ApiResponse(responseCode = "409", description = "Conflito - entidade já existe"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<CreateEntityResponse> createEntity(
            @Parameter(description = "Dados da nova entidade", required = true) CreateEntityRequest request) {
        return null; // Implementação no controller
    }
    
    @Operation(
        summary = "Atualizar entidade",
        description = "Atualiza os dados de uma entidade existente"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Entidade atualizada com sucesso"),
        @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos"),
        @ApiResponse(responseCode = "404", description = "Entidade não encontrada"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<Void> updateEntity(
            @Parameter(description = "ID da entidade", required = true) String id,
            @Parameter(description = "Dados atualizados da entidade", required = true) UpdateEntityRequest request) {
        return null; // Implementação no controller
    }
    
    @Operation(
        summary = "Adicionar contato à entidade",
        description = "Adiciona um novo contato a uma entidade existente"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "201", description = "Contato adicionado com sucesso"),
        @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos"),
        @ApiResponse(responseCode = "404", description = "Entidade não encontrada"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<Void> addEntityContact(
            @Parameter(description = "ID da entidade", required = true) String id,
            @Parameter(description = "Dados do novo contato", required = true) AddEntityContactRequest request) {
        return null; // Implementação no controller
    }
    
    @Operation(
        summary = "Remover contato da entidade",
        description = "Remove um contato de uma entidade"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Contato removido com sucesso"),
        @ApiResponse(responseCode = "404", description = "Entidade ou contato não encontrado"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<Void> removeEntityContact(
            @Parameter(description = "ID da entidade", required = true) String id,
            @Parameter(description = "ID do contato", required = true) String contactId) {
        return null; // Implementação no controller
    }
    
    @Operation(
        summary = "Excluir entidade",
        description = "Exclui (desativa) uma entidade do sistema"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Entidade excluída com sucesso"),
        @ApiResponse(responseCode = "404", description = "Entidade não encontrada"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<Void> deleteEntity(
            @Parameter(description = "ID da entidade", required = true) String id) {
        return null; // Implementação no controller
    }
    
    @Operation(
        summary = "Excluir múltiplas entidades",
        description = "Exclui (desativa) múltiplas entidades do sistema"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Entidades excluídas com sucesso"),
        @ApiResponse(responseCode = "400", description = "Lista de IDs inválida"),
        @ApiResponse(responseCode = "404", description = "Uma ou mais entidades não encontradas"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<Void> deleteEntities(
            @Parameter(description = "Lista de IDs das entidades", required = true) DeleteEntitiesRequest request) {
        return null; // Implementação no controller
    }
}
```

## 5. Testes

### 5.1 Testes Unitários

```java
@ExtendWith(MockitoExtension.class)
class LicenseEntityTest {
    
    @Mock
    private EntityType entityTypeService;
    
    @BeforeEach
    void setUp() {
        // Criar tipo de licença para testes
        LicenseType licenseType = new LicenseType();
        licenseType.setName("Tipo Teste");
        licenseType.setDescription("Descrição teste");
        licenseType.setActive(true);
        testEntityManager.persistAndFlush(licenseType);
        licenseTypeId = licenseType.getId();
    }
    
    @Test
    void shouldCreateEntitySuccessfully() {
        // Given
        List<CreateContactCommand> contacts = Arrays.asList(
            new CreateContactCommand("João Silva", "123456789", "joao@test.com", true)
        );
        
        CreateEntityCommand command = new CreateEntityCommand(
            licenseTypeId,
            "Entidade Teste",
            "DECISAO",
            "Organização Teste",
            contacts,
            "user@test.com"
        );
        
        // When
        EntityId entityId = entityService.createEntity(command);
        
        // Then
        assertThat(entityId).isNotNull();
        
        Optional<LicenseEntity> savedEntity = entityRepository.findById(entityId);
        assertThat(savedEntity).isPresent();
        assertThat(savedEntity.get().getEntityName()).isEqualTo("Entidade Teste");
        assertThat(savedEntity.get().getEntityType()).isEqualTo("DECISAO");
        assertThat(savedEntity.get().getContacts()).hasSize(1);
    }
    
    @Test
    void shouldSearchEntitiesWithFilters() {
        // Given
        createTestEntity("Entidade A", "DECISAO");
        createTestEntity("Entidade B", "PARECER");
        createTestEntity("Entidade C", "DECISAO");
        
        SearchEntitiesQuery query = new SearchEntitiesQuery(
            licenseTypeId,
            "DECISAO",
            null,
            "ACTIVE",
            0,
            10,
            "entityName",
            "ASC"
        );
        
        // When
        PagedResult<EntityListResponse> result = entityService.searchEntities(query);
        
        // Then
        assertThat(result.getContent()).hasSize(2);
        assertThat(result.getTotalElements()).isEqualTo(2);
        assertThat(result.getContent().get(0).getEntityName()).isEqualTo("Entidade A");
        assertThat(result.getContent().get(1).getEntityName()).isEqualTo("Entidade C");
    }
    
    @Test
    void shouldUpdateEntitySuccessfully() {
        // Given
        EntityId entityId = createTestEntity("Entidade Original", "DECISAO");
        
        UpdateEntityCommand command = new UpdateEntityCommand(
            entityId,
            "Entidade Atualizada",
            "PARECER",
            "Nova Organização",
            "admin@test.com"
        );
        
        // When
        entityService.updateEntity(command);
        
        // Then
        Optional<LicenseEntity> updatedEntity = entityRepository.findById(entityId);
        assertThat(updatedEntity).isPresent();
        assertThat(updatedEntity.get().getEntityName()).isEqualTo("Entidade Atualizada");
        assertThat(updatedEntity.get().getEntityType()).isEqualTo("PARECER");
        assertThat(updatedEntity.get().getUpdatedBy()).isEqualTo("admin@test.com");
    }
    
    @Test
    void shouldDeleteEntitySuccessfully() {
        // Given
        EntityId entityId = createTestEntity("Entidade Para Deletar", "DECISAO");
        
        DeleteEntityCommand command = new DeleteEntityCommand(
            entityId,
            "admin@test.com"
        );
        
        // When
        entityService.deleteEntity(command);
        
        // Then
        Optional<LicenseEntity> deletedEntity = entityRepository.findById(entityId);
        assertThat(deletedEntity).isPresent();
        assertThat(deletedEntity.get().getStatus()).isEqualTo("INACTIVE");
    }
    
    private EntityId createTestEntity(String name, String type) {
        CreateEntityCommand command = new CreateEntityCommand(
            licenseTypeId,
            name,
            type,
            null,
            Collections.emptyList(),
            "test@test.com"
        );
        return entityService.createEntity(command);
    }
}
```

### 5.3 Testes de API

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Transactional
class EntityControllerIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private EntityRepository entityRepository;
    
    @Autowired
    private LicenseTypeRepository licenseTypeRepository;
    
    @LocalServerPort
    private int port;
    
    private String baseUrl;
    private LicenseTypeId licenseTypeId;
    
    @BeforeEach
    void setUp() {
        baseUrl = "http://localhost:" + port + "/api/v1/entities";
        
        // Criar tipo de licença para testes
        LicenseType licenseType = new LicenseType();
        licenseType.setName("Tipo Teste API");
        licenseType.setDescription("Descrição teste API");
        licenseType.setActive(true);
        licenseTypeRepository.save(licenseType);
        licenseTypeId = licenseType.getId();
    }
    
    @Test
    void shouldCreateEntityViaAPI() {
        // Given
        CreateEntityRequest request = new CreateEntityRequest();
        request.setLicenseTypeId(licenseTypeId.getValue().toString());
        request.setEntityName("Entidade API Teste");
        request.setEntityType("DECISAO");
        request.setOrganizationName("Organização API");
        
        CreateContactRequest contact = new CreateContactRequest();
        contact.setContactName("João API");
        contact.setPhone("987654321");
        contact.setEmail("joao.api@test.com");
        contact.setPrimary(true);
        request.setContacts(Arrays.asList(contact));
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<CreateEntityRequest> entity = new HttpEntity<>(request, headers);
        
        // When
        ResponseEntity<CreateEntityResponse> response = restTemplate.postForEntity(
            baseUrl, entity, CreateEntityResponse.class);
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getId()).isNotNull();
    }
    
    @Test
    void shouldGetEntityListViaAPI() {
        // Given
        createTestEntityViaService("Entidade Lista 1", "DECISAO");
        createTestEntityViaService("Entidade Lista 2", "PARECER");
        
        // When
        ResponseEntity<String> response = restTemplate.getForEntity(
            baseUrl + "?licenseTypeId=" + licenseTypeId.getValue(), String.class);
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).contains("Entidade Lista 1");
        assertThat(response.getBody()).contains("Entidade Lista 2");
    }
    
    @Test
    void shouldGetEntityDetailViaAPI() {
        // Given
        EntityId entityId = createTestEntityViaService("Entidade Detalhe", "VISTORIA");
        
        // When
        ResponseEntity<EntityDetailResponse> response = restTemplate.getForEntity(
            baseUrl + "/" + entityId.getValue(), EntityDetailResponse.class);
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getEntityName()).isEqualTo("Entidade Detalhe");
        assertThat(response.getBody().getEntityType()).isEqualTo("VISTORIA");
    }
    
    @Test
    void shouldReturnNotFoundForInvalidEntityId() {
        // Given
        String invalidId = UUID.randomUUID().toString();
        
        // When
        ResponseEntity<String> response = restTemplate.getForEntity(
            baseUrl + "/" + invalidId, String.class);
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
    }
    
    @Test
    void shouldValidateRequiredFieldsOnCreate() {
        // Given
        CreateEntityRequest request = new CreateEntityRequest();
        // Não definir campos obrigatórios
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<CreateEntityRequest> entity = new HttpEntity<>(request, headers);
        
        // When
        ResponseEntity<String> response = restTemplate.postForEntity(
            baseUrl, entity, String.class);
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
    }
    
    private EntityId createTestEntityViaService(String name, String type) {
        CreateEntityCommand command = new CreateEntityCommand(
            licenseTypeId,
            name,
            type,
            null,
            Collections.emptyList(),
            "test@test.com"
        );
        
        EntityApplicationService service = new EntityApplicationService(
            entityRepository, licenseTypeRepository, null, new EntityType(null));
        return service.createEntity(command);
    }
}
```

## 6. Scripts de Migração de Dados

### 6.1 Criação das Tabelas

```sql
-- V001__create_entity_tables.sql
CREATE TABLE t_entity (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_type_id_fk UUID NOT NULL,
    organization_id_fk UUID,
    entity_name VARCHAR(255) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    
    CONSTRAINT fk_entity_license_type 
        FOREIGN KEY (license_type_id_fk) REFERENCES t_license_type(id) ON DELETE CASCADE,
    CONSTRAINT chk_entity_name_not_empty 
        CHECK (LENGTH(TRIM(entity_name)) > 0),
    CONSTRAINT chk_entity_type_valid 
        CHECK (entity_type IN ('DECISAO', 'PARECER', 'VISTORIA'))
);

CREATE TABLE t_entity_contact (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_id_fk UUID NOT NULL,
    contact_name VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    email VARCHAR(255),
    is_primary BOOLEAN NOT NULL DEFAULT false,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    
    CONSTRAINT fk_entity_contact_entity 
        FOREIGN KEY (entity_id_fk) REFERENCES t_entity(id) ON DELETE CASCADE,
    CONSTRAINT chk_contact_name_not_empty 
        CHECK (LENGTH(TRIM(contact_name)) > 0),
    CONSTRAINT chk_email_format 
        CHECK (email IS NULL OR email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$')
);

-- Índices para performance
CREATE INDEX idx_entity_license_type ON t_entity(license_type_id_fk);
CREATE INDEX idx_entity_type ON t_entity(entity_type);
CREATE INDEX idx_entity_status ON t_entity(status) WHERE status = 'ACTIVE';
CREATE INDEX idx_entity_created_at ON t_entity(created_at DESC);
CREATE INDEX idx_entity_type_status ON t_entity(license_type_id_fk, entity_type, status);
CREATE INDEX idx_entity_name_search ON t_entity USING gin(to_tsvector('portuguese', entity_name));

CREATE INDEX idx_entity_contact_entity ON t_entity_contact(entity_id_fk);
CREATE INDEX idx_entity_contact_primary ON t_entity_contact(entity_id_fk, is_primary) WHERE is_primary = true;
CREATE INDEX idx_entity_contact_email ON t_entity_contact(email) WHERE email IS NOT NULL;
```

### 6.2 Dados Iniciais

```sql
-- V002__insert_entity_options.sql
INSERT INTO t_options (ccode, ckey, cvalue, locale, sort_order, active, description) VALUES
('ENTITY_TYPE', 'DECISAO', 'Decisão', 'pt', 1, true, 'Entidade responsável por decisões no processo de licenciamento'),
('ENTITY_TYPE', 'PARECER', 'Parecer', 'pt', 2, true, 'Entidade responsável por emitir pareceres técnicos'),
('ENTITY_TYPE', 'VISTORIA', 'Vistoria', 'pt', 3, true, 'Entidade responsável por realizar vistorias');
```

## 8. Documentação de API

### 8.1 Exemplos de Uso

#### Criar Nova Entidade

```bash
curl -X POST http://localhost:8080/api/v1/entities \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{
    "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
    "entityName": "Câmara Municipal de Praia",
    "entityType": "DECISAO",
    "organizationName": "Câmara Municipal de Praia",
    "contacts": [
      {
        "contactName": "João Silva",
        "phone": "+238 260 1234",
        "email": "joao.silva@cmpraia.cv",
        "isPrimary": true
      }
    ]
  }'
```

#### Listar Entidades com Filtros

```bash
curl -X GET "http://localhost:8080/api/v1/entities?entityType=DECISAO&page=0&size=10" \
  -H "Authorization: Bearer <token>"
```

#### Obter Detalhes de uma Entidade

```bash
curl -X GET http://localhost:8080/api/v1/entities/123e4567-e89b-12d3-a456-426614174000 \
  -H "Authorization: Bearer <token>"
```

#### Atualizar Entidade

```bash
curl -X PUT http://localhost:8080/api/v1/entities/123e4567-e89b-12d3-a456-426614174000 \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{
    "entityName": "Câmara Municipal de Praia - Atualizada",
    "entityType": "DECISAO",
    "organizationName": "Câmara Municipal de Praia"
  }'
```

#### Adicionar Contato à Entidade

```bash
curl -X POST http://localhost:8080/api/v1/entities/123e4567-e89b-12d3-a456-426614174000/contacts \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{
    "contactName": "Maria Santos",
    "phone": "+238 260 5678",
    "email": "maria.santos@cmpraia.cv",
    "isPrimary": false
  }'
```

#### Excluir Entidade

```bash
curl -X DELETE http://localhost:8080/api/v1/entities/123e4567-e89b-12d3-a456-426614174000 \
  -H "Authorization: Bearer <token>"
```

#### Excluir Múltiplas Entidades

```bash
curl -X DELETE http://localhost:8080/api/v1/entities \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{
    "entityIds": [
      "123e4567-e89b-12d3-a456-426614174000",
      "123e4567-e89b-12d3-a456-426614174001"
    ]
  }'
```

### 8.2 Códigos de Resposta

| Código | Descrição             | Exemplo de Uso                             |
| ------ | --------------------- | ------------------------------------------ |
| 200    | OK                    | Operação realizada com sucesso             |
| 201    | Created               | Entidade criada com sucesso                |
| 400    | Bad Request           | Dados de entrada inválidos                 |
| 401    | Unauthorized          | Token de autenticação inválido             |
| 403    | Forbidden             | Usuário sem permissão                      |
| 404    | Not Found             | Entidade não encontrada                    |
| 409    | Conflict              | Conflito de dados (ex: entidade duplicada) |
| 422    | Unprocessable Entity  | Erro de validação de negócio               |
| 500    | Internal Server Error | Erro interno do servidor                   |

## 9. Considerações de Segurança

### 9.1 Autenticação e Autorização

```java
@Configuration
@EnableWebSecurity
public class EntitySecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/v1/entities/**").hasRole("ENTITY_MANAGER")
                .requestMatchers(HttpMethod.GET, "/api/v1/entities").hasRole("ENTITY_VIEWER")
                .requestMatchers(HttpMethod.POST, "/api/v1/entities").hasRole("ENTITY_CREATOR")
                .requestMatchers(HttpMethod.PUT, "/api/v1/entities/**").hasRole("ENTITY_EDITOR")
                .requestMatchers(HttpMethod.DELETE, "/api/v1/entities/**").hasRole("ENTITY_ADMIN")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2.jwt());
        
        return http.build();
    }
}
```

### 9.2 Validação de Entrada

```java
@Component
public class EntityInputValidator {
    
    public void validateEntityName(String entityName) {
        if (entityName == null || entityName.trim().isEmpty()) {
            throw new ValidationException("Entity name cannot be null or empty");
        }
        
        if (entityName.length() > 255) {
            throw new ValidationException("Entity name cannot exceed 255 characters");
        }
        
        // Verificar caracteres especiais perigosos
        if (entityName.matches(".*[<>\"'&].*")) {
            throw new ValidationException("Entity name contains invalid characters");
        }
    }
    
    public void validateEmail(String email) {
        if (email != null && !email.matches("^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
            throw new ValidationException("Invalid email format");
        }
    }
    
    public void validatePhone(String phone) {
        if (phone != null && !phone.matches("^\\+?[0-9\\s\\-\\(\\)]{7,20}$")) {
            throw new ValidationException("Invalid phone format");
        }
    }
}
```

## 10. Performance e Otimização

### 10.1 Cache Configuration

```java
@Configuration
@EnableCaching
public class EntityCacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        RedisCacheManager.Builder builder = RedisCacheManager
                .RedisCacheManagerBuilder
                .fromConnectionFactory(redisConnectionFactory())
                .cacheDefaults(cacheConfiguration());
        
        return builder.build();
    }
    
    private RedisCacheConfiguration cacheConfiguration() {
        return RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(30))
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer()));
    }
    
    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        return new LettuceConnectionFactory(new RedisStandaloneConfiguration("localhost", 6379));
    }
}
```

### 10.2 Query Optimization

```java
@Repository
public class OptimizedEntityQueryRepository {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    @Cacheable(value = "entity-search", key = "#query.hashCode()")
    public PagedResult<EntityListResponse> searchEntitiesOptimized(SearchEntitiesQuery query) {
        // Usar query nativa para melhor performance
        String sql = """
            SELECT e.id, e.entity_name, e.entity_type, e.status, e.created_at,
                   o.name as organization_name,
                   COUNT(c.id) as contact_count
            FROM t_entity e
            LEFT JOIN redglobal.glb_t_organization o ON e.organization_id_fk = o.id
            LEFT JOIN t_entity_contact c ON e.id = c.entity_id_fk AND c.status = 'ACTIVE'
            WHERE e.status = 'ACTIVE'
            """;
        
        // Adicionar filtros dinamicamente
        Map<String, Object> parameters = new HashMap<>();
        
        if (query.getLicenseTypeId() != null) {
            sql += " AND e.license_type_id_fk = :licenseTypeId";
            parameters.put("licenseTypeId", query.getLicenseTypeId().getValue());
        }
        
        if (query.getEntityType() != null) {
            sql += " AND e.entity_type = :entityType";
            parameters.put("entityType", query.getEntityType());
        }
        
        if (query.getEntityName() != null) {
            sql += " AND e.entity_name ILIKE :entityName";
            parameters.put("entityName", "%" + query.getEntityName() + "%");
        }
        
        sql += " GROUP BY e.id, e.entity_name, e.entity_type, e.status, e.created_at, o.name";
        sql += " ORDER BY e." + query.getSortBy() + " " + query.getSortDirection();
        
        Query nativeQuery = entityManager.createNativeQuery(sql);
        parameters.forEach(nativeQuery::setParameter);
        
        nativeQuery.setFirstResult(query.getPage() * query.getSize());
        nativeQuery.setMaxResults(query.getSize());
        
        @SuppressWarnings("unchecked")
        List<Object[]> results = nativeQuery.getResultList();
        
        // Converter resultados para DTOs
        List<EntityListResponse> responses = results.stream()
                .map(this::mapToEntityListResponse)
                .collect(Collectors.toList());
        
        // Query para contagem total
        String countSql = sql.replaceAll("SELECT.*GROUP BY.*ORDER BY.*", "SELECT COUNT(DISTINCT e.id)");
        Query countQuery = entityManager.createNativeQuery(countSql);
        parameters.forEach(countQuery::setParameter);
        long totalElements = ((Number) countQuery.getSingleResult()).longValue();
        
        return new PagedResult<>(responses, query.getPage(), query.getSize(), totalElements);
    }
    
    private EntityListResponse mapToEntityListResponse(Object[] row) {
        return new EntityListResponse(
            EntityId.of((UUID) row[0]),
            (String) row[1],
            (String) row[2],
            (String) row[5],
            ((Number) row[6]).intValue(),
            (String) row[3],
            ((Timestamp) row[4]).toInstant(),
            "system" // placeholder para created_by
        );
    }
}
```

***

## Conclusão

Este documento especifica a implementação completa do módulo de **Gestão de Entidades** para o Sistema de Licenciamento de Cabo Verde, seguindo os princípios de Domain-Driven Design (DDD) e as melhores práticas de desenvolvimento.

O módulo fornece:

* **Modelo de dados normalizado** com integridade referencial

* **Arquitetura DDD** bem estruturada com separação clara de responsabilidades

* **APIs REST** completas com documentação OpenAPI

* **Validações robustas** tanto no domínio quanto na API

* **Testes abrangentes** (unitários, integração e API)

* **Configurações de deployment** com Docker e Docker Compose

* **Monitoramento e observabilidade** com métricas customizadas

* **Considerações de segurança** e performance

A implementação está pronta para integração com o sistema existente e pode ser estendida conforme necessário para atender requisitos futuros. {
when(entityTypeService.isValidEntityType(anyString())).thenReturn(true);
}

```
@Test
void shouldCreateEntitySuccessfully() {
    // Given
    LicenseTypeId licenseTypeId = LicenseTypeId.generate();
    String entityName = "Entidade Teste";
    String entityType = "DECISAO";
    String createdBy = "user@test.com";
    
    // When
    LicenseEntity entity = LicenseEntity.create(
        licenseTypeId,
        entityName,
        entityType,
        null,
        createdBy,
        entityTypeService
    );
    
    // Then
    assertThat(entity.getId()).isNotNull();
    assertThat(entity.getLicenseTypeId()).isEqualTo(licenseTypeId);
    assertThat(entity.getEntityName()).isEqualTo(entityName);
    assertThat(entity.getEntityType()).isEqualTo(entityType);
    assertThat(entity.getStatus()).isEqualTo("ACTIVE");
    assertThat(entity.getCreatedBy()).isEqualTo(createdBy);
    assertThat(entity.getCreatedAt()).isNotNull();
}

@Test
void shouldThrowExceptionWhenEntityNameIsNull() {
    // Given
    LicenseTypeId licenseTypeId = LicenseTypeId.generate();
    String createdBy = "user@test.com";
    
    // When & Then
    assertThatThrownBy(() -> LicenseEntity.create(
        licenseTypeId,
        null,
        "DECISAO",
        null,
        createdBy,
        entityTypeService
    )).isInstanceOf(IllegalArgumentException.class)
      .hasMessage("Entity name cannot be null or empty");
}

@Test
void shouldThrowExceptionWhenEntityNameIsEmpty() {
    // Given
    LicenseTypeId licenseTypeId = LicenseTypeId.generate();
    String createdBy = "user@test.com";
    
    // When & Then
    assertThatThrownBy(() -> LicenseEntity.create(
        licenseTypeId,
        "   ",
        "DECISAO",
        null,
        createdBy,
        entityTypeService
    )).isInstanceOf(IllegalArgumentException.class)
      .hasMessage("Entity name cannot be null or empty");
}

@Test
void shouldThrowExceptionWhenEntityTypeIsInvalid() {
    // Given
    LicenseTypeId licenseTypeId = LicenseTypeId.generate();
    String entityName = "Entidade Teste";
    String invalidEntityType = "INVALID";
    String createdBy = "user@test.com";
    
    when(entityTypeService.isValidEntityType(invalidEntityType)).thenReturn(false);
    
    // When & Then
    assertThatThrownBy(() -> LicenseEntity.create(
        licenseTypeId,
        entityName,
        invalidEntityType,
        null,
        createdBy,
        entityTypeService
    )).isInstanceOf(IllegalArgumentException.class)
      .hasMessage("Invalid entity type: " + invalidEntityType);
}

@Test
void shouldAddContactSuccessfully() {
    // Given
    LicenseEntity entity = createValidEntity();
    String contactName = "João Silva";
    String phone = "123456789";
    String email = "joao@test.com";
    String createdBy = "user@test.com";
    
    // When
    entity.addContact(contactName, phone, email, true, createdBy);
    
    // Then
    assertThat(entity.getContacts()).hasSize(1);
    EntityContact contact = entity.getContacts().get(0);
    assertThat(contact.getContactName()).isEqualTo(contactName);
    assertThat(contact.getPhone()).isEqualTo(phone);
    assertThat(contact.getEmail()).isEqualTo(email);
    assertThat(contact.isPrimary()).isTrue();
}

@Test
void shouldSetOnlyOnePrimaryContact() {
    // Given
    LicenseEntity entity = createValidEntity();
    String createdBy = "user@test.com";
    
    // When
    entity.addContact("Contact 1", "111", "c1@test.com", true, createdBy);
    entity.addContact("Contact 2", "222", "c2@test.com", true, createdBy);
    
    // Then
    assertThat(entity.getContacts()).hasSize(2);
    long primaryCount = entity.getContacts().stream()
            .mapToLong(contact -> contact.isPrimary() ? 1 : 0)
            .sum();
    assertThat(primaryCount).isEqualTo(1);
    assertThat(entity.getContacts().get(1).isPrimary()).isTrue();
    assertThat(entity.getContacts().get(0).isPrimary()).isFalse();
}

@Test
void shouldUpdateEntityInfoSuccessfully() {
    // Given
    LicenseEntity entity = createValidEntity();
    String newEntityName = "Nova Entidade";
    String newEntityType = "PARECER";
    String updatedBy = "admin@test.com";
    
    // When
    entity.updateEntityInfo(newEntityName, newEntityType, null, updatedBy, entityTypeService);
    
    // Then
    assertThat(entity.getEntityName()).isEqualTo(newEntityName);
    assertThat(entity.getEntityType()).isEqualTo(newEntityType);
    assertThat(entity.getUpdatedBy()).isEqualTo(updatedBy);
    assertThat(entity.getUpdatedAt()).isNotNull();
}

@Test
void shouldDeactivateEntitySuccessfully() {
    // Given
    LicenseEntity entity = createValidEntity();
    String updatedBy = "admin@test.com";
    
    // When
    entity.deactivate(updatedBy);
    
    // Then
    assertThat(entity.getStatus()).isEqualTo("INACTIVE");
    assertThat(entity.getUpdatedBy()).isEqualTo(updatedBy);
    assertThat(entity.getUpdatedAt()).isNotNull();
}

private LicenseEntity createValidEntity() {
    return LicenseEntity.create(
        LicenseTypeId.generate(),
        "Entidade Teste",
        "DECISAO",
        null,
        "user@test.com",
        entityTypeService
    );
}
```

}

````

### 5.2 Testes de Integração

```java
@SpringBootTest
@Transactional
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
class EntityApplicationServiceIntegrationTest {
    
    @Autowired
    private EntityApplicationService entityService;
    
    @Autowired
    private EntityRepository entityRepository;
    
    @Autowired
    private LicenseTypeRepository licenseTypeRepository;
    
    @Autowired
    private TestEntityManager testEntityManager;
    
    private LicenseTypeId licenseTypeId;
    
    @BeforeEach
    void setUp()
````

