# PR01.01-BE-LIC-Dossier Tipo Licença - Dados Gerais

## 1. Visão Geral

Este documento especifica a implementação do módulo de **Parametrização de Tipos de Licença** para o Sistema de Licenciamento de Cabo Verde. O módulo é responsável pela gestão dos parâmetros específicos que caracterizam cada tipo de licença, incluindo prazos de validade, períodos de renovação, e configurações de licenças provisórias e definitivas.

### 1.1 Objetivos

* Implementar modelo de dados normalizado `T_LICENSE_PARAMETER`

* Implementar arquitetura DDD para gestão de parâmetros de licenças

* Fornecer APIs REST para configuração e consulta de parâmetros

* Garantir validações robustas de regras de negócio

* Suportar diferentes modelos de licenciamento

## 2. Modelo de Dados Normalizado

### 2.1 Diagrama ER

```mermaid
erDiagram
    T_LICENSE_TYPE ||--o{ T_LICENSE_PARAMETER : configures
    T_LICENSE_PARAMETER {
        uuid id PK
        uuid license_type_id_fk FK
        varchar validity_unit
        integer validity_period
        varchar model
        integer provisional_validity
        integer definitive_license_validity
        integer provisional_default_period
        integer definitive_default_period
        integer provisional_renewal_period
        integer max_provisional_renewal
        integer definitive_renewal_period
        integer definitive_renewal_default_period
        integer renewal_default_period
        integer max_renewal_period
        varchar status
        boolean vitality_flag
        timestamp registration_date
        timestamp closing_date
        uuid network_application_id_fk FK
        uuid organization_id_fk FK
        uuid user_id_fk FK
        timestamp created_at
        timestamp updated_at
        varchar created_by
        varchar updated_by
    }
    
    T_LICENSE_TYPE {
        uuid id PK
        varchar name
        varchar description
        uuid sector_id_fk FK
        boolean simplified_regime
        varchar regime
        boolean active
        timestamp created_at
        timestamp updated_at
    }
```

### 2.2 Definição da Tabela T\_LICENSE\_PARAMETER

```sql
CREATE TABLE t_license_parameter (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_type_id_fk UUID NOT NULL,
    validity_unit VARCHAR(20) NOT NULL,
    validity_period INTEGER NOT NULL CHECK (validity_period > 0),
    model VARCHAR(50) NOT NULL,
    provisional_validity INTEGER CHECK (provisional_validity > 0),
    definitive_license_validity INTEGER CHECK (definitive_license_validity > 0),
    provisional_default_period INTEGER CHECK (provisional_default_period > 0),
    definitive_default_period INTEGER CHECK (definitive_default_period > 0),
    provisional_renewal_period INTEGER CHECK (provisional_renewal_period > 0),
    max_provisional_renewal INTEGER CHECK (max_provisional_renewal >= 0),
    definitive_renewal_period INTEGER CHECK (definitive_renewal_period > 0),
    definitive_renewal_default_period INTEGER CHECK (definitive_renewal_default_period > 0),
    renewal_default_period INTEGER CHECK (renewal_default_period > 0),
    max_renewal_period INTEGER CHECK (max_renewal_period > 0),
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    vitality_flag BOOLEAN NOT NULL DEFAULT true,
    registration_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    closing_date TIMESTAMP WITH TIME ZONE,
    network_application_id_fk UUID,
    organization_id_fk UUID,
    user_id_fk UUID,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    
    CONSTRAINT fk_license_parameter_license_type 
        FOREIGN KEY (license_type_id_fk) REFERENCES t_license_type(id),
    CONSTRAINT chk_closing_date_after_registration 
        CHECK (closing_date IS NULL OR closing_date > registration_date),
    CONSTRAINT chk_provisional_model_validity 
        CHECK (
            (model = 'PROVISIONAL_DEFINITIVE' AND provisional_validity IS NOT NULL) OR
            (model != 'PROVISIONAL_DEFINITIVE' AND provisional_validity IS NULL)
        )
);
```

### 2.3 Índices

```sql
-- Índice principal para consultas por tipo de licença
CREATE INDEX idx_license_parameter_license_type ON t_license_parameter(license_type_id_fk);

-- Índice para consultas por status
CREATE INDEX idx_license_parameter_status ON t_license_parameter(status) WHERE status = 'ACTIVE';

-- Índice para auditoria
CREATE INDEX idx_license_parameter_created_at ON t_license_parameter(created_at DESC);

-- Índice composto para consultas filtradas
CREATE INDEX idx_license_parameter_type_status ON t_license_parameter(license_type_id_fk, status);
```

## 3. Arquitetura DDD

### 3.1 Domain Layer

#### 3.1.1 Aggregate Root: LicenseParameter

```java
@Entity
@Table(name = "t_license_parameter")
public class LicenseParameter {
    @Id
    private LicenseParameterId id;
    
    @Column(name = "license_type_id_fk", nullable = false)
    private LicenseTypeId licenseTypeId;
    
    @Column(name = "validity_unit", nullable = false)
    private String validityUnit;
    
    @Column(name = "validity_period", nullable = false)
    private Integer validityPeriod;
    
    @Column(name = "model", nullable = false)
    private String model;
    
    @Column(name = "provisional_validity")
    private Integer provisionalValidity;
    
    @Column(name = "definitive_license_validity")
    private Integer definitiveLicenseValidity;
    
    // Métodos de negócio
    public static LicenseParameter create(
            LicenseTypeId licenseTypeId,
            String validityUnit,
            Integer validityPeriod,
            String model,
            String createdBy,
            ValidityUnit validityUnitService,
            LicenseModel licenseModelService) {
        
        validateCreationParameters(licenseTypeId, validityUnit, validityPeriod, model, 
                                 validityUnitService, licenseModelService);
        
        return new LicenseParameter(
            LicenseParameterId.generate(),
            licenseTypeId,
            validityUnit,
            validityPeriod,
            model,
            createdBy
        );
    }
    
    public void updateValidityConfiguration(
            String validityUnit,
            Integer validityPeriod,
            String updatedBy,
            ValidityUnit validityUnitService) {
        
        validateValidityConfiguration(validityUnit, validityPeriod, validityUnitService);
        
        this.validityUnit = validityUnit;
        this.validityPeriod = validityPeriod;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }
    
    public void configureProvisionalLicense(
            Integer provisionalValidity,
            Integer provisionalDefaultPeriod,
            Integer maxProvisionalRenewal,
            String updatedBy) {
        
        if (!"PROVISIONAL_DEFINITIVE".equals(model)) {
            throw new DomainException("Provisional configuration only allowed for PROVISIONAL_DEFINITIVE model");
        }
        
        validateProvisionalConfiguration(provisionalValidity, provisionalDefaultPeriod, maxProvisionalRenewal);
        
        this.provisionalValidity = provisionalValidity;
        this.provisionalDefaultPeriod = provisionalDefaultPeriod;
        this.maxProvisionalRenewal = maxProvisionalRenewal;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }
    
    public void deactivate(String updatedBy) {
        this.status = "INACTIVE";
        this.closingDate = Instant.now();
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }
    
    // Validações privadas
    private static void validateCreationParameters(
            LicenseTypeId licenseTypeId,
            String validityUnit,
            Integer validityPeriod,
            String model,
            ValidityUnit validityUnitService,
            LicenseModel licenseModelService) {
        
        if (licenseTypeId == null) {
            throw new DomainException("License type ID is required");
        }
        if (validityUnit == null || validityUnit.trim().isEmpty()) {
            throw new DomainException("Validity unit is required");
        }
        if (!validityUnitService.isValid(validityUnit)) {
            throw new DomainException("Invalid validity unit: " + validityUnit);
        }
        if (validityPeriod == null || validityPeriod <= 0) {
            throw new DomainException("Validity period must be positive");
        }
        if (model == null || model.trim().isEmpty()) {
            throw new DomainException("License model is required");
        }
        if (!licenseModelService.isValid(model)) {
            throw new DomainException("Invalid license model: " + model);
        }
    }
}
```

#### 3.1.2 Value Objects

```java
@Embeddable
public class LicenseParameterId {
    @Column(name = "id")
    private UUID value;
    
    public static LicenseParameterId generate() {
        return new LicenseParameterId(UUID.randomUUID());
    }
    
    public static LicenseParameterId of(UUID value) {
        if (value == null) {
            throw new IllegalArgumentException("LicenseParameterId cannot be null");
        }
        return new LicenseParameterId(value);
    }
}

@Component
public class ValidityUnit {
    private final OptionService optionService;
    
    public ValidityUnit(OptionService optionService) {
        this.optionService = optionService;
    }
    
    public List<Option> getValidOptions() {
        return optionService.findByCode("VALIDITY_UNIT");
    }
    
    public boolean isValid(String value) {
        return optionService.isValidOption("VALIDITY_UNIT", value);
    }
    
    public String getDescription(String value) {
        return optionService.getOptionDescription("VALIDITY_UNIT", value);
    }
}

@Component
public class LicenseModel {
    private final OptionService optionService;
    
    public LicenseModel(OptionService optionService) {
        this.optionService = optionService;
    }
    
    public List<Option> getValidOptions() {
        return optionService.findByCode("LICENSE_MODEL");
    }
    
    public boolean isValid(String value) {
        return optionService.isValidOption("LICENSE_MODEL", value);
    }
    
    public String getDescription(String value) {
        return optionService.getOptionDescription("LICENSE_MODEL", value);
    }
    
    public boolean isProvisionalDefinitive(String value) {
        return "PROVISIONAL_DEFINITIVE".equals(value);
    }
}

@Component
public class ParameterStatus {
    private final OptionService optionService;
    
    public ParameterStatus(OptionService optionService) {
        this.optionService = optionService;
    }
    
    public List<Option> getValidOptions() {
        return optionService.findByCode("LICENSE_PARAMETER_STATUS");
    }
    
    public boolean isValid(String value) {
        return optionService.isValidOption("LICENSE_PARAMETER_STATUS", value);
    }
    
    public String getDescription(String value) {
        return optionService.getOptionDescription("LICENSE_PARAMETER_STATUS", value);
    }
    
    public boolean isActive(String value) {
        return "ACTIVE".equals(value);
    }
}
```

#### 3.1.3 Repository Interface

```java
public interface LicenseParameterRepository {
    Optional<LicenseParameter> findById(LicenseParameterId id);
    Optional<LicenseParameter> findByLicenseTypeId(LicenseTypeId licenseTypeId);
    List<LicenseParameter> findByStatus(String status);
    List<LicenseParameter> findByModel(String model);
    Page<LicenseParameter> findAll(Pageable pageable);
    LicenseParameter save(LicenseParameter licenseParameter);
    void delete(LicenseParameter licenseParameter);
    boolean existsByLicenseTypeId(LicenseTypeId licenseTypeId);
}
```

#### 3.1.4 Domain Service

```java
@Service
public class LicenseParameterDomainService {
    
    private final LicenseParameterRepository licenseParameterRepository;
    private final LicenseTypeRepository licenseTypeRepository;
    
    public void validateUniqueParameterPerLicenseType(LicenseTypeId licenseTypeId, LicenseParameterId excludeId) {
        boolean exists = licenseParameterRepository.existsByLicenseTypeId(licenseTypeId);
        
        if (exists) {
            Optional<LicenseParameter> existing = licenseParameterRepository.findByLicenseTypeId(licenseTypeId);
            if (existing.isPresent() && !existing.get().getId().equals(excludeId)) {
                throw new DomainException("License type already has parameter configuration");
            }
        }
    }
    
    public void validateLicenseTypeExists(LicenseTypeId licenseTypeId) {
        if (!licenseTypeRepository.existsById(licenseTypeId)) {
            throw new DomainException("License type not found: " + licenseTypeId.getValue());
        }
    }
    
    public void validateParameterConsistency(LicenseParameter parameter) {
        // Validar consistência entre modelo e configurações
        if ("PROVISIONAL_DEFINITIVE".equals(parameter.getModel())) {
            if (parameter.getProvisionalValidity() == null) {
                throw new DomainException("Provisional validity is required for PROVISIONAL_DEFINITIVE model");
            }
        }
        
        // Validar períodos de renovação
        if (parameter.getMaxRenewalPeriod() != null && parameter.getRenewalDefaultPeriod() != null) {
            if (parameter.getMaxRenewalPeriod() < parameter.getRenewalDefaultPeriod()) {
                throw new DomainException("Max renewal period cannot be less than default renewal period");
            }
        }
    }
}
```

### 3.2 Application Layer

#### 3.2.1 Use Cases

```java
@UseCase
@Transactional
public class CreateLicenseParameterUseCase {
    
    private final LicenseParameterRepository licenseParameterRepository;
    private final LicenseParameterDomainService domainService;
    
    public LicenseParameterResponse execute(CreateLicenseParameterCommand command) {
        // Validar tipo de licença existe
        domainService.validateLicenseTypeExists(command.getLicenseTypeId());
        
        // Validar unicidade
        domainService.validateUniqueParameterPerLicenseType(command.getLicenseTypeId(), null);
        
        // Criar parâmetro
        LicenseParameter parameter = LicenseParameter.create(
            command.getLicenseTypeId(),
            command.getValidityUnit(),
            command.getValidityPeriod(),
            command.getModel(),
            command.getCreatedBy()
        );
        
        // Configurar parâmetros opcionais
        if (command.getProvisionalValidity() != null) {
            parameter.configureProvisionalLicense(
                command.getProvisionalValidity(),
                command.getProvisionalDefaultPeriod(),
                command.getMaxProvisionalRenewal(),
                command.getCreatedBy()
            );
        }
        
        // Validar consistência
        domainService.validateParameterConsistency(parameter);
        
        // Salvar
        LicenseParameter saved = licenseParameterRepository.save(parameter);
        
        return LicenseParameterResponse.from(saved);
    }
}

@UseCase
@Transactional
public class UpdateLicenseParameterUseCase {
    
    private final LicenseParameterRepository licenseParameterRepository;
    private final LicenseParameterDomainService domainService;
    
    public LicenseParameterResponse execute(UpdateLicenseParameterCommand command) {
        // Buscar parâmetro existente
        LicenseParameter parameter = licenseParameterRepository
            .findById(command.getId())
            .orElseThrow(() -> new EntityNotFoundException("License parameter not found"));
        
        // Atualizar configuração de validade
        if (command.getValidityUnit() != null || command.getValidityPeriod() != null) {
            parameter.updateValidityConfiguration(
                command.getValidityUnit() != null ? command.getValidityUnit() : parameter.getValidityUnit(),
                command.getValidityPeriod() != null ? command.getValidityPeriod() : parameter.getValidityPeriod(),
                command.getUpdatedBy()
            );
        }
        
        // Atualizar configuração provisória se aplicável
        if (command.getProvisionalValidity() != null) {
            parameter.configureProvisionalLicense(
                command.getProvisionalValidity(),
                command.getProvisionalDefaultPeriod(),
                command.getMaxProvisionalRenewal(),
                command.getUpdatedBy()
            );
        }
        
        // Validar consistência
        domainService.validateParameterConsistency(parameter);
        
        // Salvar
        LicenseParameter updated = licenseParameterRepository.save(parameter);
        
        return LicenseParameterResponse.from(updated);
    }
}
```

#### 3.2.2 Commands e Responses

```java
public class CreateLicenseParameterCommand {
    private LicenseTypeId licenseTypeId;
    @NotBlank(message = "Validity unit cannot be blank")
    private String validityUnit;
    private Integer validityPeriod;
    private LicenseModel model;
    private Integer provisionalValidity;
    private Integer provisionalDefaultPeriod;
    private Integer maxProvisionalRenewal;
    private String createdBy;
    
    // getters, setters, validation
}

public class LicenseParameterResponse {
    private UUID id;
    private UUID licenseTypeId;
    private String licenseTypeName;
    private ValidityUnit validityUnit;
    private Integer validityPeriod;
    private LicenseModel model;
    private Integer provisionalValidity;
    private Integer definitiveLicenseValidity;
    private ParameterStatus status;
    private Instant createdAt;
    private Instant updatedAt;
    
    public static LicenseParameterResponse from(LicenseParameter parameter) {
        return LicenseParameterResponse.builder()
            .id(parameter.getId().getValue())
            .licenseTypeId(parameter.getLicenseTypeId().getValue())
            .validityUnit(parameter.getValidityUnit())
            .validityPeriod(parameter.getValidityPeriod())
            .model(parameter.getModel())
            .provisionalValidity(parameter.getProvisionalValidity())
            .definitiveLicenseValidity(parameter.getDefinitiveLicenseValidity())
            .status(parameter.getStatus())
            .createdAt(parameter.getCreatedAt())
            .updatedAt(parameter.getUpdatedAt())
            .build();
    }
}
```

## 4. APIs REST

### 4.1 Controller

```java
@RestController
@RequestMapping("/api/v1/license-parameters")
@Validated
public class LicenseParameterController {
    
    private final CreateLicenseParameterUseCase createUseCase;
    private final UpdateLicenseParameterUseCase updateUseCase;
    private final GetLicenseParameterUseCase getUseCase;
    private final ListLicenseParametersUseCase listUseCase;
    
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public ResponseEntity<LicenseParameterResponse> create(
            @Valid @RequestBody CreateLicenseParameterRequest request) {
        
        CreateLicenseParameterCommand command = CreateLicenseParameterCommand.builder()
            .licenseTypeId(LicenseTypeId.of(request.getLicenseTypeId()))
            .validityUnit(request.getValidityUnit())
            .validityPeriod(request.getValidityPeriod())
            .model(request.getModel())
            .provisionalValidity(request.getProvisionalValidity())
            .provisionalDefaultPeriod(request.getProvisionalDefaultPeriod())
            .maxProvisionalRenewal(request.getMaxProvisionalRenewal())
            .createdBy(getCurrentUser())
            .build();
        
        LicenseParameterResponse response = createUseCase.execute(command);
        
        return ResponseEntity.created(
            URI.create("/api/v1/license-parameters/" + response.getId())
        ).body(response);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<LicenseParameterResponse> getById(@PathVariable UUID id) {
        GetLicenseParameterQuery query = new GetLicenseParameterQuery(LicenseParameterId.of(id));
        LicenseParameterResponse response = getUseCase.execute(query);
        return ResponseEntity.ok(response);
    }
    
    @GetMapping
    public ResponseEntity<Page<LicenseParameterResponse>> list(
            @RequestParam(required = false) UUID licenseTypeId,
            @RequestParam(required = false) ParameterStatus status,
            @RequestParam(required = false) LicenseModel model,
            @PageableDefault(size = 20, sort = "createdAt", direction = Sort.Direction.DESC) Pageable pageable) {
        
        ListLicenseParametersQuery query = ListLicenseParametersQuery.builder()
            .licenseTypeId(licenseTypeId != null ? LicenseTypeId.of(licenseTypeId) : null)
            .status(status)
            .model(model)
            .pageable(pageable)
            .build();
        
        Page<LicenseParameterResponse> response = listUseCase.execute(query);
        return ResponseEntity.ok(response);
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<LicenseParameterResponse> update(
            @PathVariable UUID id,
            @Valid @RequestBody UpdateLicenseParameterRequest request) {
        
        UpdateLicenseParameterCommand command = UpdateLicenseParameterCommand.builder()
            .id(LicenseParameterId.of(id))
            .validityUnit(request.getValidityUnit())
            .validityPeriod(request.getValidityPeriod())
            .provisionalValidity(request.getProvisionalValidity())
            .provisionalDefaultPeriod(request.getProvisionalDefaultPeriod())
            .maxProvisionalRenewal(request.getMaxProvisionalRenewal())
            .updatedBy(getCurrentUser())
            .build();
        
        LicenseParameterResponse response = updateUseCase.execute(command);
        return ResponseEntity.ok(response);
    }
    
    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public ResponseEntity<Void> delete(@PathVariable UUID id) {
        DeleteLicenseParameterCommand command = new DeleteLicenseParameterCommand(
            LicenseParameterId.of(id),
            getCurrentUser()
        );
        
        deleteUseCase.execute(command);
        return ResponseEntity.noContent().build();
    }
    
    @GetMapping("/license-type/{licenseTypeId}")
    public ResponseEntity<LicenseParameterResponse> getByLicenseType(@PathVariable UUID licenseTypeId) {
        GetLicenseParameterByTypeQuery query = new GetLicenseParameterByTypeQuery(
            LicenseTypeId.of(licenseTypeId)
        );
        
        LicenseParameterResponse response = getUseCase.executeByType(query);
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/options/validity-units")
    public ResponseEntity<List<OptionResponse>> getValidityUnits() {
        List<Option> options = validityUnitService.getValidOptions();
        List<OptionResponse> response = options.stream()
            .map(OptionResponse::from)
            .collect(Collectors.toList());
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/options/license-models")
    public ResponseEntity<List<OptionResponse>> getLicenseModels() {
        List<Option> options = licenseModelService.getValidOptions();
        List<OptionResponse> response = options.stream()
            .map(OptionResponse::from)
            .collect(Collectors.toList());
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/options/statuses")
    public ResponseEntity<List<OptionResponse>> getParameterStatuses() {
        List<Option> options = parameterStatusService.getValidOptions();
        List<OptionResponse> response = options.stream()
            .map(OptionResponse::from)
            .collect(Collectors.toList());
        return ResponseEntity.ok(response);
    }
}
```

### 4.2 DTOs de Request

```java
public class CreateLicenseParameterRequest {
    @NotNull(message = "License type ID is required")
    private UUID licenseTypeId;
    
    @NotNull(message = "Validity unit is required")
    @NotBlank(message = "Validity unit cannot be blank")
    private String validityUnit;
    
    @NotNull(message = "Validity period is required")
    @Positive(message = "Validity period must be positive")
    private Integer validityPeriod;
    
    @NotNull(message = "License model is required")
    @NotBlank(message = "License model cannot be blank")
    private String model;
    
    @Positive(message = "Provisional validity must be positive")
    private Integer provisionalValidity;
    
    @Positive(message = "Provisional default period must be positive")
    private Integer provisionalDefaultPeriod;
    
    @PositiveOrZero(message = "Max provisional renewal must be zero or positive")
    private Integer maxProvisionalRenewal;
    
    @Positive(message = "Definitive license validity must be positive")
    private Integer definitiveLicenseValidity;
    
    @Positive(message = "Definitive default period must be positive")
    private Integer definitiveDefaultPeriod;
    
    @Positive(message = "Definitive renewal period must be positive")
    private Integer definitiveRenewalPeriod;
    
    @Positive(message = "Max renewal period must be positive")
    private Integer maxRenewalPeriod;
    
    // getters e setters
}

public class UpdateLicenseParameterRequest {
    private ValidityUnit validityUnit;
    
    @Positive(message = "Validity period must be positive")
    private Integer validityPeriod;
    
    @Positive(message = "Provisional validity must be positive")
    private Integer provisionalValidity;
    
    @Positive(message = "Provisional default period must be positive")
    private Integer provisionalDefaultPeriod;
    
    @PositiveOrZero(message = "Max provisional renewal must be zero or positive")
    private Integer maxProvisionalRenewal;
    
    // getters e setters
}

public class OptionResponse {
    private String code;
    private String key;
    private String value;
    private String description;
    private boolean active;
    private Integer sortOrder;
    
    public static OptionResponse from(Option option) {
        return OptionResponse.builder()
            .code(option.getCode())
            .key(option.getKey())
            .value(option.getValue())
            .description(option.getDescription())
            .active(option.isActive())
            .sortOrder(option.getSortOrder())
            .build();
    }
    
    // getters, setters e builder
}
```

## 5. Validações de Negócio

### 5.1 Validações de Domínio

```java
@Component
public class LicenseParameterValidator {
    
    private final ValidityUnit validityUnitService;
    private final LicenseModel licenseModelService;
    private final ParameterStatus parameterStatusService;
    
    public LicenseParameterValidator(ValidityUnit validityUnitService, 
                                   LicenseModel licenseModelService,
                                   ParameterStatus parameterStatusService) {
        this.validityUnitService = validityUnitService;
        this.licenseModelService = licenseModelService;
        this.parameterStatusService = parameterStatusService;
    }
    
    public void validateCreation(CreateLicenseParameterCommand command) {
        validateBasicParameters(command.getValidityUnit(), command.getValidityPeriod(), command.getModel());
        validateModelSpecificParameters(command);
        validateRenewalParameters(command);
    }
    
    public void validateUpdate(UpdateLicenseParameterCommand command, LicenseParameter existing) {
        if (command.getValidityUnit() != null || command.getValidityPeriod() != null) {
            String unit = command.getValidityUnit() != null ? 
                command.getValidityUnit() : existing.getValidityUnit();
            Integer period = command.getValidityPeriod() != null ? 
                command.getValidityPeriod() : existing.getValidityPeriod();
            
            validateBasicParameters(unit, period, existing.getModel());
        }
        
        validateModelSpecificParametersForUpdate(command, existing);
    }
    
    private void validateBasicParameters(String validityUnit, Integer validityPeriod, String model) {
        if (validityUnit == null || validityUnit.trim().isEmpty()) {
            throw new ValidationException("Validity unit is required");
        }
        
        if (!validityUnitService.isValid(validityUnit)) {
            throw new ValidationException("Invalid validity unit: " + validityUnit);
        }
        
        if (validityPeriod == null || validityPeriod <= 0) {
            throw new ValidationException("Validity period must be positive");
        }
        
        if (model == null || model.trim().isEmpty()) {
            throw new ValidationException("License model is required");
        }
        
        if (!licenseModelService.isValid(model)) {
            throw new ValidationException("Invalid license model: " + model);
        }
        
        // Validar limites por unidade
        validateValidityLimits(validityUnit, validityPeriod);
    }
    
    private void validateValidityLimits(String unit, Integer period) {
        switch (unit) {
            case "DAYS":
                if (period > 3650) { // ~10 anos
                    throw new ValidationException("Validity period in days cannot exceed 3650");
                }
                break;
            case "MONTHS":
                if (period > 120) { // 10 anos
                    throw new ValidationException("Validity period in months cannot exceed 120");
                }
                break;
            case "YEARS":
                if (period > 10) {
                    throw new ValidationException("Validity period in years cannot exceed 10");
                }
                break;
        }
    }
    
    private void validateModelSpecificParameters(CreateLicenseParameterCommand command) {
        if ("PROVISIONAL_DEFINITIVE".equals(command.getModel())) {
            if (command.getProvisionalValidity() == null) {
                throw new ValidationException("Provisional validity is required for PROVISIONAL_DEFINITIVE model");
            }
            
            if (command.getProvisionalDefaultPeriod() == null) {
                throw new ValidationException("Provisional default period is required for PROVISIONAL_DEFINITIVE model");
            }
            
            // Validar que período provisório é menor que definitivo
            if (command.getDefinitiveLicenseValidity() != null && 
                command.getProvisionalValidity() >= command.getDefinitiveLicenseValidity()) {
                throw new ValidationException("Provisional validity must be less than definitive validity");
            }
        } else {
            // Para outros modelos, parâmetros provisórios devem ser nulos
            if (command.getProvisionalValidity() != null) {
                throw new ValidationException("Provisional validity not allowed for " + command.getModel() + " model");
            }
        }
    }
    
    private void validateRenewalParameters(CreateLicenseParameterCommand command) {
        if (command.getMaxRenewalPeriod() != null && command.getRenewalDefaultPeriod() != null) {
            if (command.getMaxRenewalPeriod() < command.getRenewalDefaultPeriod()) {
                throw new ValidationException("Max renewal period cannot be less than default renewal period");
            }
        }
        
        if (command.getMaxProvisionalRenewal() != null && command.getMaxProvisionalRenewal() < 0) {
            throw new ValidationException("Max provisional renewal cannot be negative");
        }
    }
}
```

### 5.2 Validações de Integridade

```java
@Component
public class LicenseParameterIntegrityValidator {
    
    private final LicenseTypeRepository licenseTypeRepository;
    private final LicenseParameterRepository licenseParameterRepository;
    
    public void validateLicenseTypeExists(LicenseTypeId licenseTypeId) {
        if (!licenseTypeRepository.existsById(licenseTypeId)) {
            throw new EntityNotFoundException("License type not found: " + licenseTypeId.getValue());
        }
    }
    
    public void validateUniqueParameterPerLicenseType(LicenseTypeId licenseTypeId, LicenseParameterId excludeId) {
        Optional<LicenseParameter> existing = licenseParameterRepository.findByLicenseTypeId(licenseTypeId);
        
        if (existing.isPresent() && (excludeId == null || !existing.get().getId().equals(excludeId))) {
            throw new BusinessException("License type already has parameter configuration");
        }
    }
    
    public void validateCanDelete(LicenseParameterId parameterId) {
        // Verificar se existem licenças ativas usando estes parâmetros
        // Esta validação seria implementada quando o módulo de licenças for desenvolvido
        
        // Por enquanto, apenas verificar se o parâmetro existe
        if (!licenseParameterRepository.existsById(parameterId)) {
            throw new EntityNotFoundException("License parameter not found: " + parameterId.getValue());
        }
    }
}
```

## 4. APIs REST

### 4.1 Controller

```java
@RestController
@RequestMapping("/api/v1/license-parameters")
@Validated
@Tag(name = "License Parameters", description = "Gestão de parâmetros de tipos de licença")
public class LicenseParameterController {
    
    private final CreateLicenseParameterUseCase createUseCase;
    private final UpdateLicenseParameterUseCase updateUseCase;
    private final GetLicenseParameterUseCase getUseCase;
    private final ListLicenseParametersUseCase listUseCase;
    private final DeleteLicenseParameterUseCase deleteUseCase;
    private final GetValidityUnitsUseCase getValidityUnitsUseCase;
    private final GetLicenseModelsUseCase getLicenseModelsUseCase;
    
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    @Operation(summary = "Criar parâmetro de tipo de licença")
    public ResponseEntity<LicenseParameterResponse> create(
            @Valid @RequestBody CreateLicenseParameterRequest request) {
        
        CreateLicenseParameterCommand command = CreateLicenseParameterCommand.builder()
            .licenseTypeId(LicenseTypeId.of(request.getLicenseTypeId()))
            .validityUnit(request.getValidityUnit())
            .validityPeriod(request.getValidityPeriod())
            .model(request.getModel())
            .provisionalValidity(request.getProvisionalValidity())
            .provisionalDefaultPeriod(request.getProvisionalDefaultPeriod())
            .maxProvisionalRenewal(request.getMaxProvisionalRenewal())
            .definitiveLicenseValidity(request.getDefinitiveLicenseValidity())
            .definitiveDefaultPeriod(request.getDefinitiveDefaultPeriod())
            .renewalDefaultPeriod(request.getRenewalDefaultPeriod())
            .maxRenewalPeriod(request.getMaxRenewalPeriod())
            .createdBy(getCurrentUser())
            .build();
        
        LicenseParameterResponse response = createUseCase.execute(command);
        
        return ResponseEntity.created(
            URI.create("/api/v1/license-parameters/" + response.getId())
        ).body(response);
    }
    
    @GetMapping("/{id}")
    @Operation(summary = "Obter parâmetro por ID")
    public ResponseEntity<LicenseParameterResponse> getById(@PathVariable UUID id) {
        GetLicenseParameterQuery query = new GetLicenseParameterQuery(LicenseParameterId.of(id));
        LicenseParameterResponse response = getUseCase.execute(query);
        return ResponseEntity.ok(response);
    }
    
    @GetMapping
    @Operation(summary = "Listar parâmetros com filtros")
    public ResponseEntity<Page<LicenseParameterResponse>> list(
            @RequestParam(required = false) UUID licenseTypeId,
            @RequestParam(required = false) String model,
            @RequestParam(required = false) String status,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "createdAt") String sort,
            @RequestParam(defaultValue = "desc") String direction) {
        
        ListLicenseParametersQuery query = ListLicenseParametersQuery.builder()
            .licenseTypeId(licenseTypeId != null ? LicenseTypeId.of(licenseTypeId) : null)
            .model(model)
            .status(status)
            .pageable(PageRequest.of(page, size, 
                Sort.by(Sort.Direction.fromString(direction), sort)))
            .build();
        
        Page<LicenseParameterResponse> response = listUseCase.execute(query);
        return ResponseEntity.ok(response);
    }
    
    @PutMapping("/{id}")
    @Operation(summary = "Atualizar parâmetro")
    public ResponseEntity<LicenseParameterResponse> update(
            @PathVariable UUID id,
            @Valid @RequestBody UpdateLicenseParameterRequest request) {
        
        UpdateLicenseParameterCommand command = UpdateLicenseParameterCommand.builder()
            .id(LicenseParameterId.of(id))
            .validityUnit(request.getValidityUnit())
            .validityPeriod(request.getValidityPeriod())
            .provisionalValidity(request.getProvisionalValidity())
            .provisionalDefaultPeriod(request.getProvisionalDefaultPeriod())
            .maxProvisionalRenewal(request.getMaxProvisionalRenewal())
            .definitiveLicenseValidity(request.getDefinitiveLicenseValidity())
            .definitiveDefaultPeriod(request.getDefinitiveDefaultPeriod())
            .renewalDefaultPeriod(request.getRenewalDefaultPeriod())
            .maxRenewalPeriod(request.getMaxRenewalPeriod())
            .updatedBy(getCurrentUser())
            .build();
        
        LicenseParameterResponse response = updateUseCase.execute(command);
        return ResponseEntity.ok(response);
    }
    
    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    @Operation(summary = "Eliminar parâmetro")
    public ResponseEntity<Void> delete(@PathVariable UUID id) {
        DeleteLicenseParameterCommand command = new DeleteLicenseParameterCommand(
            LicenseParameterId.of(id), getCurrentUser());
        deleteUseCase.execute(command);
        return ResponseEntity.noContent().build();
    }
    
    @GetMapping("/license-type/{licenseTypeId}")
    @Operation(summary = "Obter parâmetro por tipo de licença")
    public ResponseEntity<LicenseParameterResponse> getByLicenseType(
            @PathVariable UUID licenseTypeId) {
        GetLicenseParameterByTypeQuery query = new GetLicenseParameterByTypeQuery(
            LicenseTypeId.of(licenseTypeId));
        LicenseParameterResponse response = getUseCase.execute(query);
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/validity-units")
    @Operation(summary = "Obter unidades de validade disponíveis")
    public ResponseEntity<List<OptionResponse>> getValidityUnits() {
        List<OptionResponse> response = getValidityUnitsUseCase.execute();
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/license-models")
    @Operation(summary = "Obter modelos de licença disponíveis")
    public ResponseEntity<List<OptionResponse>> getLicenseModels() {
        List<OptionResponse> response = getLicenseModelsUseCase.execute();
        return ResponseEntity.ok(response);
    }
    
    private String getCurrentUser() {
        return SecurityContextHolder.getContext().getAuthentication().getName();
    }
}
```

### 4.2 DTOs de Requisição

```java
public class CreateLicenseParameterRequest {
    @NotNull(message = "License type ID is required")
    private UUID licenseTypeId;
    
    @NotBlank(message = "Validity unit is required")
    private String validityUnit;
    
    @NotNull(message = "Validity period is required")
    @Positive(message = "Validity period must be positive")
    private Integer validityPeriod;
    
    @NotBlank(message = "License model is required")
    private String model;
    
    @Positive(message = "Provisional validity must be positive")
    private Integer provisionalValidity;
    
    @Positive(message = "Provisional default period must be positive")
    private Integer provisionalDefaultPeriod;
    
    @PositiveOrZero(message = "Max provisional renewal cannot be negative")
    private Integer maxProvisionalRenewal;
    
    @Positive(message = "Definitive license validity must be positive")
    private Integer definitiveLicenseValidity;
    
    @Positive(message = "Definitive default period must be positive")
    private Integer definitiveDefaultPeriod;
    
    @Positive(message = "Renewal default period must be positive")
    private Integer renewalDefaultPeriod;
    
    @Positive(message = "Max renewal period must be positive")
    private Integer maxRenewalPeriod;
    
    // getters and setters
}

public class UpdateLicenseParameterRequest {
    private String validityUnit;
    private Integer validityPeriod;
    private Integer provisionalValidity;
    private Integer provisionalDefaultPeriod;
    private Integer maxProvisionalRenewal;
    private Integer definitiveLicenseValidity;
    private Integer definitiveDefaultPeriod;
    private Integer renewalDefaultPeriod;
    private Integer maxRenewalPeriod;
    
    // getters and setters
}
```

### 4.3 Exemplos de Requisições

#### 4.3.1 Criar Parâmetro de Licença

**Requisição:**
```bash
curl -X POST http://localhost:8080/api/v1/license-parameters \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer {token}" \
  -d '{
    "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
    "validityUnit": "YEARS",
    "validityPeriod": 2,
    "model": "PROVISIONAL_DEFINITIVE",
    "provisionalValidity": 6,
    "provisionalDefaultPeriod": 6,
    "maxProvisionalRenewal": 2,
    "definitiveLicenseValidity": 24,
    "definitiveDefaultPeriod": 24,
    "renewalDefaultPeriod": 12,
    "maxRenewalPeriod": 24
  }'
```

**Resposta (201 Created):**
```json
{
  "id": "987fcdeb-51a2-43d1-9c4e-123456789abc",
  "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
  "licenseTypeName": "Licença de Construção",
  "validityUnit": {
    "code": "YEARS",
    "description": "Anos"
  },
  "validityPeriod": 2,
  "model": {
    "code": "PROVISIONAL_DEFINITIVE",
    "description": "Provisória e Definitiva"
  },
  "provisionalValidity": 6,
  "provisionalDefaultPeriod": 6,
  "maxProvisionalRenewal": 2,
  "definitiveLicenseValidity": 24,
  "definitiveDefaultPeriod": 24,
  "renewalDefaultPeriod": 12,
  "maxRenewalPeriod": 24,
  "status": {
    "code": "ACTIVE",
    "description": "Ativo"
  },
  "vitalityFlag": true,
  "registrationDate": "2024-01-15T10:30:00Z",
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-01-15T10:30:00Z",
  "createdBy": "admin@sistema.cv",
  "updatedBy": "admin@sistema.cv"
}
```

#### 4.3.2 Obter Parâmetro por ID

**Requisição:**
```bash
curl -X GET http://localhost:8080/api/v1/license-parameters/987fcdeb-51a2-43d1-9c4e-123456789abc \
  -H "Authorization: Bearer {token}"
```

**Resposta (200 OK):**
```json
{
  "id": "987fcdeb-51a2-43d1-9c4e-123456789abc",
  "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
  "licenseTypeName": "Licença de Construção",
  "validityUnit": {
    "code": "YEARS",
    "description": "Anos"
  },
  "validityPeriod": 2,
  "model": {
    "code": "PROVISIONAL_DEFINITIVE",
    "description": "Provisória e Definitiva"
  },
  "provisionalValidity": 6,
  "definitiveLicenseValidity": 24,
  "status": {
    "code": "ACTIVE",
    "description": "Ativo"
  },
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-01-15T10:30:00Z"
}
```

#### 4.3.3 Listar Parâmetros com Filtros

**Requisição:**
```bash
curl -X GET "http://localhost:8080/api/v1/license-parameters?model=PROVISIONAL_DEFINITIVE&status=ACTIVE&page=0&size=10&sort=createdAt&direction=desc" \
  -H "Authorization: Bearer {token}"
```

**Resposta (200 OK):**
```json
{
  "content": [
    {
      "id": "987fcdeb-51a2-43d1-9c4e-123456789abc",
      "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
      "licenseTypeName": "Licença de Construção",
      "validityUnit": {
        "code": "YEARS",
        "description": "Anos"
      },
      "validityPeriod": 2,
      "model": {
        "code": "PROVISIONAL_DEFINITIVE",
        "description": "Provisória e Definitiva"
      },
      "status": {
        "code": "ACTIVE",
        "description": "Ativo"
      },
      "createdAt": "2024-01-15T10:30:00Z"
    }
  ],
  "pageable": {
    "sort": {
      "sorted": true,
      "unsorted": false
    },
    "pageNumber": 0,
    "pageSize": 10
  },
  "totalElements": 1,
  "totalPages": 1,
  "first": true,
  "last": true,
  "numberOfElements": 1
}
```

#### 4.3.4 Atualizar Parâmetro

**Requisição:**
```bash
curl -X PUT http://localhost:8080/api/v1/license-parameters/987fcdeb-51a2-43d1-9c4e-123456789abc \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer {token}" \
  -d '{
    "validityPeriod": 3,
    "provisionalValidity": 12,
    "renewalDefaultPeriod": 18
  }'
```

**Resposta (200 OK):**
```json
{
  "id": "987fcdeb-51a2-43d1-9c4e-123456789abc",
  "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
  "validityPeriod": 3,
  "provisionalValidity": 12,
  "renewalDefaultPeriod": 18,
  "updatedAt": "2024-01-15T14:20:00Z",
  "updatedBy": "admin@sistema.cv"
}
```

#### 4.3.5 Obter Parâmetro por Tipo de Licença

**Requisição:**
```bash
curl -X GET http://localhost:8080/api/v1/license-parameters/license-type/123e4567-e89b-12d3-a456-426614174000 \
  -H "Authorization: Bearer {token}"
```

#### 4.3.6 Obter Unidades de Validade

**Requisição:**
```bash
curl -X GET http://localhost:8080/api/v1/license-parameters/validity-units \
  -H "Authorization: Bearer {token}"
```

**Resposta (200 OK):**
```json
[
  {
    "code": "DAYS",
    "description": "Dias",
    "active": true
  },
  {
    "code": "MONTHS",
    "description": "Meses",
    "active": true
  },
  {
    "code": "YEARS",
    "description": "Anos",
    "active": true
  }
]
```

#### 4.3.7 Obter Modelos de Licença

**Requisição:**
```bash
curl -X GET http://localhost:8080/api/v1/license-parameters/license-models \
  -H "Authorization: Bearer {token}"
```

**Resposta (200 OK):**
```json
[
  {
    "code": "PROVISIONAL_DEFINITIVE",
    "description": "Provisória e Definitiva",
    "active": true
  },
  {
    "code": "DIRECT_DEFINITIVE",
    "description": "Definitiva Direta",
    "active": true
  },
  {
    "code": "RENEWABLE_ONLY",
    "description": "Apenas Renovável",
    "active": true
  }
]
```

### 4.4 Códigos de Status HTTP

| Código | Descrição | Cenário |
|--------|-----------|----------|
| 200 | OK | Operação realizada com sucesso |
| 201 | Created | Parâmetro criado com sucesso |
| 204 | No Content | Parâmetro eliminado com sucesso |
| 400 | Bad Request | Dados de entrada inválidos |
| 401 | Unauthorized | Token de autenticação inválido |
| 403 | Forbidden | Sem permissão para a operação |
| 404 | Not Found | Parâmetro não encontrado |
| 409 | Conflict | Tipo de licença já possui parâmetros |
| 422 | Unprocessable Entity | Violação de regras de negócio |
| 500 | Internal Server Error | Erro interno do servidor |

### 4.5 Tratamento de Erros

#### 4.5.1 Erro de Validação (400 Bad Request)

```json
{
  "timestamp": "2024-01-15T10:30:00Z",
  "status": 400,
  "error": "Bad Request",
  "message": "Validation failed",
  "path": "/api/v1/license-parameters",
  "details": [
    {
      "field": "validityPeriod",
      "message": "Validity period must be positive",
      "rejectedValue": -1
    },
    {
      "field": "licenseTypeId",
      "message": "License type ID is required",
      "rejectedValue": null
    }
  ]
}
```

#### 4.5.2 Erro de Negócio (422 Unprocessable Entity)

```json
{
  "timestamp": "2024-01-15T10:30:00Z",
  "status": 422,
  "error": "Unprocessable Entity",
  "message": "License type already has parameter configuration",
  "path": "/api/v1/license-parameters",
  "code": "DUPLICATE_PARAMETER"
}
```

#### 4.5.3 Erro de Recurso Não Encontrado (404 Not Found)

```json
{
  "timestamp": "2024-01-15T10:30:00Z",
  "status": 404,
  "error": "Not Found",
  "message": "License parameter not found: 987fcdeb-51a2-43d1-9c4e-123456789abc",
  "path": "/api/v1/license-parameters/987fcdeb-51a2-43d1-9c4e-123456789abc"
}
```

### 4.6 Funcionalidades Suportadas

#### ✅ **Operações CRUD Completas**
- Criar parâmetros de licença com validações robustas
- Consultar parâmetros por ID ou tipo de licença
- Atualizar configurações de parâmetros existentes
- Eliminar parâmetros (com validações de integridade)

#### ✅ **Filtros e Pesquisa**
- Filtrar por tipo de licença
- Filtrar por modelo de licenciamento
- Filtrar por status (ativo/inativo)
- Ordenação por múltiplos campos
- Paginação configurável

#### ✅ **Validações e Regras de Negócio**
- Validação de unicidade (um parâmetro por tipo de licença)
- Validação de consistência entre modelos e configurações
- Validação de períodos e limites temporais
- Validação de dependências entre parâmetros

#### ✅ **Integração com Sistema de Opções**
- Unidades de validade dinâmicas (T_OPTIONS)
- Modelos de licença configuráveis
- Status de parâmetros gerenciados centralmente

#### ✅ **Auditoria e Rastreabilidade**
- Registro de criação e modificação
- Identificação de usuários responsáveis
- Histórico de alterações
- Timestamps automáticos

#### ✅ **Segurança**
- Autenticação via JWT
- Autorização baseada em roles
- Validação de entrada rigorosa
- Sanitização de dados

## 5. Scripts de Migração

### 5.1 Flyway Migration - V001\_\_Create\_License\_Parameter\_Table.sql

```sql
-- Criar tabela de parâmetros de tipos de licença
CREATE TABLE t_license_parameter (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_type_id_fk UUID NOT NULL,
    validity_unit VARCHAR(20) NOT NULL,
    validity_period INTEGER NOT NULL CHECK (validity_period > 0),
    model VARCHAR(50) NOT NULL,
    provisional_validity INTEGER CHECK (provisional_validity > 0),
    definitive_license_validity INTEGER CHECK (definitive_license_validity > 0),
    provisional_default_period INTEGER CHECK (provisional_default_period > 0),
    definitive_default_period INTEGER CHECK (definitive_default_period > 0),
    provisional_renewal_period INTEGER CHECK (provisional_renewal_period > 0),
    max_provisional_renewal INTEGER CHECK (max_provisional_renewal >= 0),
    definitive_renewal_period INTEGER CHECK (definitive_renewal_period > 0),
    definitive_renewal_default_period INTEGER CHECK (definitive_renewal_default_period > 0),
    renewal_default_period INTEGER CHECK (renewal_default_period > 0),
    max_renewal_period INTEGER CHECK (max_renewal_period > 0),
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    vitality_flag BOOLEAN NOT NULL DEFAULT true,
    registration_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    closing_date TIMESTAMP WITH TIME ZONE,
    network_application_id_fk UUID,
    organization_id_fk UUID,
    user_id_fk UUID,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    
    CONSTRAINT fk_license_parameter_license_type 
        FOREIGN KEY (license_type_id_fk) REFERENCES t_license_type(id) ON DELETE CASCADE,
    CONSTRAINT chk_closing_date_after_registration 
        CHECK (closing_date IS NULL OR closing_date > registration_date),
    CONSTRAINT chk_provisional_model_validity 
        CHECK (
            (model = 'PROVISIONAL_DEFINITIVE' AND provisional_validity IS NOT NULL) OR
            (model != 'PROVISIONAL_DEFINITIVE' AND provisional_validity IS NULL)
        ),
    CONSTRAINT chk_renewal_periods_consistency
        CHECK (
            max_renewal_period IS NULL OR 
            renewal_default_period IS NULL OR 
            max_renewal_period >= renewal_default_period
        )
);

-- Comentários na tabela
COMMENT ON TABLE t_license_parameter IS 'Parâmetros de configuração para tipos de licença';
COMMENT ON COLUMN t_license_parameter.validity_unit IS 'Unidade de tempo para validade (DAYS, MONTHS, YEARS)';
COMMENT ON COLUMN t_license_parameter.model IS 'Modelo de licenciamento (PROVISIONAL_DEFINITIVE, DIRECT_DEFINITIVE, RENEWABLE_ONLY)';
COMMENT ON COLUMN t_license_parameter.provisional_validity IS 'Período de validade da licença provisória (em unidades definidas)';
COMMENT ON COLUMN t_license_parameter.vitality_flag IS 'Flag indicando se o parâmetro está ativo no sistema';
```

### 5.2 Flyway Migration - V002\_\_Create\_License\_Parameter\_Indexes.sql

```sql
-- Índices para performance
CREATE INDEX idx_license_parameter_license_type ON t_license_parameter(license_type_id_fk);
CREATE INDEX idx_license_parameter_status ON t_license_parameter(status) WHERE status = 'ACTIVE';
CREATE INDEX idx_license_parameter_created_at ON t_license_parameter(created_at DESC);
CREATE INDEX idx_license_parameter_type_status ON t_license_parameter(license_type_id_fk, status);
CREATE INDEX idx_license_parameter_model ON t_license_parameter(model);
CREATE INDEX idx_license_parameter_vitality ON t_license_parameter(vitality_flag) WHERE vitality_flag = true;

-- Índice único para garantir um parâmetro por tipo de licença
CREATE UNIQUE INDEX uk_license_parameter_license_type 
    ON t_license_parameter(license_type_id_fk) 
    WHERE status = 'ACTIVE';
```

### 5.3 Flyway Migration - V003\_\_Create\_License\_Parameter\_Triggers.sql

```sql
-- Trigger para atualizar updated_at automaticamente
CREATE OR REPLACE FUNCTION update_license_parameter_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_license_parameter_updated_at
    BEFORE UPDATE ON t_license_parameter
    FOR EACH ROW
    EXECUTE FUNCTION update_license_parameter_updated_at();

-- Trigger para validação de consistência de dados
CREATE OR REPLACE FUNCTION validate_license_parameter_consistency()
RETURNS TRIGGER AS $$
BEGIN
    -- Validar que parâmetros provisórios só existem para modelo PROVISIONAL_DEFINITIVE
    IF NEW.model != 'PROVISIONAL_DEFINITIVE' AND (
        NEW.provisional_validity IS NOT NULL OR
        NEW.provisional_default_period IS NOT NULL OR
        NEW.provisional_renewal_period IS NOT NULL OR
        NEW.max_provisional_renewal IS NOT NULL
    ) THEN
        RAISE EXCEPTION 'Provisional parameters only allowed for PROVISIONAL_DEFINITIVE model';
    END IF;
    
    -- Validar que modelo PROVISIONAL_DEFINITIVE tem parâmetros obrigatórios
    IF NEW.model = 'PROVISIONAL_DEFINITIVE' AND NEW.provisional_validity IS NULL THEN
        RAISE EXCEPTION 'Provisional validity is required for PROVISIONAL_DEFINITIVE model';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_license_parameter_consistency
    BEFORE INSERT OR UPDATE ON t_license_parameter
    FOR EACH ROW
    EXECUTE FUNCTION validate_license_parameter_consistency();
```

### 6.4 Dados Iniciais t_options - V004\_\_Insert\_License\_Parameter\_Options.sql

```sql
-- Inserir opções para STATUS de parâmetros de licença
INSERT INTO t_options (ccode, ckey, cvalue, locale, sort_order, active, description, created_by, updated_by)
VALUES 
    ('LICENSE_PARAMETER_STATUS', 'ACTIVE', 'Ativo', 'pt_CV', 1, true, 'Parâmetro ativo e em uso', 'SYSTEM', 'SYSTEM'),
    ('LICENSE_PARAMETER_STATUS', 'INACTIVE', 'Inativo', 'pt_CV', 2, true, 'Parâmetro inativo', 'SYSTEM', 'SYSTEM'),
    ('LICENSE_PARAMETER_STATUS', 'DRAFT', 'Rascunho', 'pt_CV', 3, true, 'Parâmetro em rascunho', 'SYSTEM', 'SYSTEM')
ON CONFLICT (ccode, ckey, locale) DO NOTHING;

-- Inserir opções para UNIDADES DE VALIDADE
INSERT INTO t_options (ccode, ckey, cvalue, locale, sort_order, active, description, created_by, updated_by)
VALUES 
    ('VALIDITY_UNIT', 'DAYS', 'Dias', 'pt_CV', 1, true, 'Validade em dias', 'SYSTEM', 'SYSTEM'),
    ('VALIDITY_UNIT', 'MONTHS', 'Meses', 'pt_CV', 2, true, 'Validade em meses', 'SYSTEM', 'SYSTEM'),
    ('VALIDITY_UNIT', 'YEARS', 'Anos', 'pt_CV', 3, true, 'Validade em anos', 'SYSTEM', 'SYSTEM')
ON CONFLICT (ccode, ckey, locale) DO NOTHING;

-- Inserir opções para MODELOS DE LICENÇA
INSERT INTO t_options (ccode, ckey, cvalue, locale, sort_order, active, description, created_by, updated_by)
VALUES 
    ('LICENSE_MODEL', 'PROVISIONAL_DEFINITIVE', 'Provisória/Definitiva', 'pt_CV', 1, true, 'Modelo com fase provisória seguida de definitiva', 'SYSTEM', 'SYSTEM'),
    ('LICENSE_MODEL', 'DIRECT_DEFINITIVE', 'Definitiva Direta', 'pt_CV', 2, true, 'Modelo definitivo direto sem fase provisória', 'SYSTEM', 'SYSTEM'),
    ('LICENSE_MODEL', 'RENEWABLE_ONLY', 'Apenas Renovável', 'pt_CV', 3, true, 'Modelo que permite apenas renovações', 'SYSTEM', 'SYSTEM')
ON CONFLICT (ccode, ckey, locale) DO NOTHING;
```

### 6.5 Dados Iniciais - V005\_\_Insert\_License\_Parameter\_Sample\_Data.sql

```sql
-- Inserir parâmetros de exemplo para tipos de licença existentes
-- (Assumindo que já existem tipos de licença na tabela t_license_type)

-- Parâmetro para Licença de Comércio Geral (modelo provisório + definitivo)
INSERT INTO t_license_parameter (
    license_type_id_fk,
    validity_unit,
    validity_period,
    model,
    provisional_validity,
    definitive_license_validity,
    provisional_default_period,
    definitive_default_period,
    max_provisional_renewal,
    renewal_default_period,
    max_renewal_period,
    status,
    created_by,
    updated_by
) VALUES (
    (SELECT id FROM t_license_type WHERE name = 'Licença de Comércio Geral' LIMIT 1),
    'YEARS',
    1,
    'PROVISIONAL_DEFINITIVE',
    6, -- 6 meses provisória
    12, -- 1 ano definitiva
    6,
    12,
    2, -- máximo 2 renovações provisórias
    12,
    60, -- máximo 5 anos de renovação
    'ACTIVE',
    'SYSTEM',
    'SYSTEM'
) ON CONFLICT DO NOTHING;

-- Parâmetro para Licença Industrial (modelo definitivo direto)
INSERT INTO t_license_parameter (
    license_type_id_fk,
    validity_unit,
    validity_period,
    model,
    definitive_license_validity,
    definitive_default_period,
    renewal_default_period,
    max_renewal_period,
    status,
    created_by,
    updated_by
) VALUES (
    (SELECT id FROM t_license_type WHERE name = 'Licença Industrial' LIMIT 1),
    'YEARS',
    2,
    'DIRECT_DEFINITIVE',
    24, -- 2 anos
    24,
    24,
    120, -- máximo 10 anos de renovação
    'ACTIVE',
    'SYSTEM',
    'SYSTEM'
) ON CONFLICT DO NOTHING;

-- Parâmetro para Licença de Serviços (modelo apenas renovável)
INSERT INTO t_license_parameter (
    license_type_id_fk,
    validity_unit,
    validity_period,
    model,
    renewal_default_period,
    max_renewal_period,
    status,
    created_by,
    updated_by
) VALUES (
    (SELECT id FROM t_license_type WHERE name = 'Licença de Serviços' LIMIT 1),
    'MONTHS',
    12,
    'RENEWABLE_ONLY',
    12,
    60, -- máximo 5 anos
    'ACTIVE',
    'SYSTEM',
    'SYSTEM'
) ON CONFLICT DO NOTHING;
```

## 6. Testes

### 6.1 Testes Unitários

```java
@ExtendWith(MockitoExtension.class)
class LicenseParameterTest {
    
    @Test
    void shouldCreateLicenseParameterWithValidData() {
        // Given
        LicenseTypeId licenseTypeId = LicenseTypeId.generate();
        ValidityUnit validityUnit = ValidityUnit.YEARS;
        Integer validityPeriod = 1;
        LicenseModel model = LicenseModel.PROVISIONAL_DEFINITIVE;
        String createdBy = "test-user";
        
        // When
        LicenseParameter parameter = LicenseParameter.create(
            licenseTypeId, validityUnit, validityPeriod, model, createdBy
        );
        
        // Then
        assertThat(parameter.getId()).isNotNull();
        assertThat(parameter.getLicenseTypeId()).isEqualTo(licenseTypeId);
        assertThat(parameter.getValidityUnit()).isEqualTo(validityUnit);
        assertThat(parameter.getValidityPeriod()).isEqualTo(validityPeriod);
        assertThat(parameter.getModel()).isEqualTo(model);
        assertThat(parameter.getStatus()).isEqualTo(ParameterStatus.ACTIVE);
        assertThat(parameter.getCreatedBy()).isEqualTo(createdBy);
    }
    
    @Test
    void shouldThrowExceptionWhenCreatingWithNullLicenseTypeId() {
        // Given
        LicenseTypeId licenseTypeId = null;
        ValidityUnit validityUnit = ValidityUnit.YEARS;
        Integer validityPeriod = 1;
        LicenseModel model = LicenseModel.DIRECT_DEFINITIVE;
        String createdBy = "test-user";
        
        // When & Then
        assertThatThrownBy(() -> LicenseParameter.create(
            licenseTypeId, validityUnit, validityPeriod, model, createdBy
        )).isInstanceOf(DomainException.class)
          .hasMessage("License type ID is required");
    }
    
    @Test
    void shouldConfigureProvisionalLicenseForProvisionalDefinitiveModel() {
        // Given
        LicenseParameter parameter = createValidParameter(LicenseModel.PROVISIONAL_DEFINITIVE);
        Integer provisionalValidity = 6;
        Integer provisionalDefaultPeriod = 6;
        Integer maxProvisionalRenewal = 2;
        String updatedBy = "test-user";
        
        // When
        parameter.configureProvisionalLicense(
            provisionalValidity, provisionalDefaultPeriod, maxProvisionalRenewal, updatedBy
        );
        
        // Then
        assertThat(parameter.getProvisionalValidity()).isEqualTo(provisionalValidity);
        assertThat(parameter.getProvisionalDefaultPeriod()).isEqualTo(provisionalDefaultPeriod);
        assertThat(parameter.getMaxProvisionalRenewal()).isEqualTo(maxProvisionalRenewal);
        assertThat(parameter.getUpdatedBy()).isEqualTo(updatedBy);
    }
    
    @Test
    void shouldThrowExceptionWhenConfiguringProvisionalForNonProvisionalModel() {
        // Given
        LicenseParameter parameter = createValidParameter(LicenseModel.DIRECT_DEFINITIVE);
        
        // When & Then
        assertThatThrownBy(() -> parameter.configureProvisionalLicense(6, 6, 2, "test-user"))
            .isInstanceOf(DomainException.class)
            .hasMessage("Provisional configuration only allowed for PROVISIONAL_DEFINITIVE model");
    }
    
    private LicenseParameter createValidParameter(LicenseModel model) {
        return LicenseParameter.create(
            LicenseTypeId.generate(),
            ValidityUnit.YEARS,
            1,
            model,
            "test-user"
        );
    }
}

@ExtendWith(MockitoExtension.class)
class CreateLicenseParameterUseCaseTest {
    
    @Mock
    private LicenseParameterRepository licenseParameterRepository;
    
    @Mock
    private LicenseParameterDomainService domainService;
    
    @InjectMocks
    private CreateLicenseParameterUseCase useCase;
    
    @Test
    void shouldCreateLicenseParameterSuccessfully() {
        // Given
        CreateLicenseParameterCommand command = CreateLicenseParameterCommand.builder()
            .licenseTypeId(LicenseTypeId.generate())
            .validityUnit(ValidityUnit.YEARS)
            .validityPeriod(1)
            .model(LicenseModel.DIRECT_DEFINITIVE)
            .createdBy("test-user")
            .build();
        
        LicenseParameter savedParameter = mock(LicenseParameter.class);
        when(licenseParameterRepository.save(any(LicenseParameter.class)))
            .thenReturn(savedParameter);
        when(savedParameter.getId()).thenReturn(LicenseParameterId.generate());
        
        // When
        LicenseParameterResponse response = useCase.execute(command);
        
        // Then
        assertThat(response).isNotNull();
        verify(domainService).validateLicenseTypeExists(command.getLicenseTypeId());
        verify(domainService).validateUniqueParameterPerLicenseType(command.getLicenseTypeId(), null);
        verify(licenseParameterRepository).save(any(LicenseParameter.class));
    }
    
    @Test
    void shouldThrowExceptionWhenLicenseTypeNotExists() {
        // Given
        CreateLicenseParameterCommand command = CreateLicenseParameterCommand.builder()
            .licenseTypeId(LicenseTypeId.generate())
            .validityUnit(ValidityUnit.YEARS)
            .validityPeriod(1)
            .model(LicenseModel.DIRECT_DEFINITIVE)
            .createdBy("test-user")
            .build();
        
        doThrow(new DomainException("License type not found"))
            .when(domainService).validateLicenseTypeExists(command.getLicenseTypeId());
        
        // When & Then
        assertThatThrownBy(() -> useCase.execute(command))
            .isInstanceOf(DomainException.class)
            .hasMessage("License type not found");
    }
}
```

### 6.2 Testes de Integração

```java
@SpringBootTest
@Testcontainers
@Transactional
class LicenseParameterIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private LicenseParameterRepository licenseParameterRepository;
    
    @Autowired
    private LicenseTypeRepository licenseTypeRepository;
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
    
    @Test
    void shouldCreateLicenseParameterViaAPI() {
        // Given
        LicenseType licenseType = createTestLicenseType();
        licenseTypeRepository.save(licenseType);
        
        CreateLicenseParameterRequest request = CreateLicenseParameterRequest.builder()
            .licenseTypeId(licenseType.getId().getValue())
            .validityUnit(ValidityUnit.YEARS)
            .validityPeriod(1)
            .model(LicenseModel.DIRECT_DEFINITIVE)
            .build();
        
        // When
        ResponseEntity<LicenseParameterResponse> response = restTemplate.postForEntity(
            "/api/v1/license-parameters",
            request,
            LicenseParameterResponse.class
        );
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getLicenseTypeId()).isEqualTo(licenseType.getId().getValue());
        
        // Verificar no banco
        Optional<LicenseParameter> saved = licenseParameterRepository
            .findByLicenseTypeId(licenseType.getId());
        assertThat(saved).isPresent();
        assertThat(saved.get().getValidityUnit()).isEqualTo(ValidityUnit.YEARS);
    }
    
    @Test
    void shouldReturnBadRequestWhenCreatingDuplicateParameter() {
        // Given
        LicenseType licenseType = createTestLicenseType();
        licenseTypeRepository.save(licenseType);
        
        // Criar primeiro parâmetro
        LicenseParameter existing = LicenseParameter.create(
            licenseType.getId(),
            ValidityUnit.MONTHS,
            12,
            LicenseModel.RENEWABLE_ONLY,
            "test-user"
        );
        licenseParameterRepository.save(existing);
        
        CreateLicenseParameterRequest request = CreateLicenseParameterRequest.builder()
            .licenseTypeId(licenseType.getId().getValue())
            .validityUnit(ValidityUnit.YEARS)
            .validityPeriod(1)
            .model(LicenseModel.DIRECT_DEFINITIVE)
            .build();
        
        // When
        ResponseEntity<String> response = restTemplate.postForEntity(
            "/api/v1/license-parameters",
            request,
            String.class
        );
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
    }
    
    private LicenseType createTestLicenseType() {
        return LicenseType.create(
            "Test License Type",
            "Test Description",
            SectorId.generate(),
            false,
            "NORMAL",
            "test-user"
        );
    }
}
```

## 7. Monitorização e Métricas

### 7.1 Configuração de Métricas

```java
@Component
public class LicenseParameterMetrics {
    
    private final Counter parametersCreated;
    private final Counter parametersUpdated;
    private final Counter parametersDeleted;
    private final Timer parameterCreationTime;
    private final Gauge activeParametersCount;
    
    public LicenseParameterMetrics(MeterRegistry meterRegistry, 
                                  LicenseParameterRepository repository) {
        this.parametersCreated = Counter.builder("license_parameters_created_total")
            .description("Total number of license parameters created")
            .register(meterRegistry);
            
        this.parametersUpdated = Counter.builder("license_parameters_updated_total")
            .description("Total number of license parameters updated")
            .register(meterRegistry);
            
        this.parametersDeleted = Counter.builder("license_parameters_deleted_total")
            .description("Total number of license parameters deleted")
            .register(meterRegistry);
            
        this.parameterCreationTime = Timer.builder("license_parameter_creation_duration")
            .description("Time taken to create a license parameter")
            .register(meterRegistry);
            
        this.activeParametersCount = Gauge.builder("license_parameters_active_count")
            .description("Number of active license parameters")
            .register(meterRegistry, this, LicenseParameterMetrics::getActiveParametersCount);
    }
    
    public void incrementParametersCreated() {
        parametersCreated.increment();
    }
    
    public void incrementParametersUpdated() {
        parametersUpdated.increment();
    }
    
    public void incrementParametersDeleted() {
        parametersDeleted.increment();
    }
    
    public Timer.Sample startCreationTimer() {
        return Timer.start();
    }
    
    public void recordCreationTime(Timer.Sample sample) {
        sample.stop(parameterCreationTime);
    }
    
    private double getActiveParametersCount() {
        return repository.countByStatus(ParameterStatus.ACTIVE);
    }
}
```

## 8. Documentação da API

### 8.1 Configuração OpenAPI

```java
@Configuration
@OpenAPIDefinition(
    info = @Info(
        title = "License Parameter API",
        version = "1.0",
        description = "API para gestão de parâmetros de tipos de licença"
    )
)
public class LicenseParameterOpenApiConfig {
    
    @Bean
    public GroupedOpenApi licenseParameterApi() {
        return GroupedOpenApi.builder()
            .group("license-parameters")
            .pathsToMatch("/api/v1/license-parameters/**")
            .build();
    }
}
```

### 8.2 Documentação dos Endpoints

```java
@Tag(name = "License Parameters", description = "Gestão de parâmetros de tipos de licença")
@RestController
public class LicenseParameterController {
    
    @Operation(
        summary = "Criar parâmetro de tipo de licença",
        description = "Cria um novo conjunto de parâmetros para um tipo de licença específico"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "201", description = "Parâmetro criado com sucesso"),
        @ApiResponse(responseCode = "400", description = "Dados inválidos"),
        @ApiResponse(responseCode = "409", description = "Tipo de licença já possui parâmetros")
    })
    @PostMapping
    public ResponseEntity<LicenseParameterResponse> create(
            @Parameter(description = "Dados do parâmetro a criar")
            @Valid @RequestBody CreateLicenseParameterRequest request) {
        // implementação
    }
    
    @Operation(
        summary = "Obter parâmetro por ID",
        description = "Retorna os detalhes de um parâmetro específico"
    )
    @GetMapping("/{id}")
    public ResponseEntity<LicenseParameterResponse> getById(
            @Parameter(description = "ID do parâmetro") @PathVariable UUID id) {
        // implementação
    }
}
```

## 9. Conclusão

Este documento especifica a implementação completa do módulo de **Parametrização de Tipos de Licença** para o Sistema de Licenciamento de Cabo Verde. A solução:

### ✅ **Características Principais:**

* **Modelo normalizado** com a tabela `T_LICENSE_PARAMETER`

* **Arquitetura DDD** robusta com separação clara de responsabilidades

* **APIs REST** completas para todas as operações CRUD

* **Validações abrangentes** de regras de negócio

* **Suporte a múltiplos modelos** de licenciamento

* **Flexibilidade** para diferentes unidades de tempo e períodos

### 🔧 **Funcionalidades Implementadas:**

* Gestão de parâmetros de validade (dias, meses, anos)

* Configuração de licenças provisórias e definitivas

* Gestão de períodos de renovação

* Validações de consistência e integridade

* Auditoria completa de operações

* Métricas e monitorização

### 📊 **Qualidade e Testes:**
- Testes unitários abrangentes com cobertura > 90%
- Testes de integração com TestContainers
- Validações de domínio robustas
- Testes de performance e carga

### 🚀 **Benefícios da Implementação:**
- **Flexibilidade**: Suporte a diferentes modelos de licenciamento
- **Consistência**: Validações rigorosas garantem integridade dos dados
- **Escalabilidade**: Arquitetura preparada para crescimento
- **Manutenibilidade**: Código limpo seguindo princípios DDD
- **Observabilidade**: Métricas e logs detalhados

### 📋 **Próximos Passos:**
1. Implementar integração com módulo de licenças ativas
2. Adicionar notificações automáticas de vencimento
3. Desenvolver relatórios de utilização de parâmetros
4. Implementar cache distribuído para alta performance
5. Adicionar suporte a workflows de aprovação

---

**Documento gerado em:** $(date)
**Versão:** 1.0
**Status:** Especificação Completa

