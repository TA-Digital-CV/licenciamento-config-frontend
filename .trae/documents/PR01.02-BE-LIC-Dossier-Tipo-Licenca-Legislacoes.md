# PR01.02-BE-LIC-Dossier Tipo Licença - Legislações

## 1. Visão Geral

Este documento especifica a implementação do módulo de **Gestão de Legislações** para o Sistema de Licenciamento de Cabo Verde. O módulo é responsável pela gestão das legislações e documentos normativos associados aos tipos de licença, incluindo upload, armazenamento e consulta de documentos legais.

### 1.1 Objetivos

* Normalizar o modelo de dados da tabela `GLIC_T_LEGISLACAO` para `T_LEGISLATION`

* Implementar arquitetura DDD para gestão de legislações

* Fornecer APIs REST para CRUD de legislações com filtros avançados

* Integrar com sistema de armazenamento de documentos (Minio)

* Garantir validações robustas e integridade referencial

* Suportar múltiplos tipos de legislação parametrizáveis

## 2. Modelo de Dados Normalizado

### 2.1 Diagrama ER

```mermaid
erDiagram
    T_LICENSE_TYPE ||--o{ T_LEGISLATION : "has legislation"
    T_LEGISLATION {
        uuid id PK
        uuid license_type_id_fk FK
        varchar name
        varchar legislation_type
        date publication_date
        varchar republic_bulletin
        text description
        varchar document_url
        varchar document_name
        varchar document_mime_type
        bigint document_size
        varchar status
        timestamp created_at
        timestamp updated_at
        varchar created_by
        varchar updated_by
    }
    
    T_LICENSE_TYPE {
        uuid id PK
        varchar name
        varchar description
        uuid sector_id_fk FK
        boolean simplified_regime
        varchar regime
        boolean active
        timestamp created_at
        timestamp updated_at
    }
    
    T_OPTIONS {
        uuid id PK
        varchar ccode
        varchar ckey
        varchar cvalue
        varchar locale
        integer sort_order
        boolean active
        text description
        timestamp created_at
        timestamp updated_at
    }
```

### 2.2 Definição da Tabela T\_LEGISLATION

```sql
CREATE TABLE t_legislation (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_type_id_fk UUID NOT NULL,
    name VARCHAR(255) NOT NULL,
    legislation_type VARCHAR(50) NOT NULL,
    publication_date DATE,
    republic_bulletin VARCHAR(100),
    description TEXT,
    document_url VARCHAR(500),
    document_name VARCHAR(255),
    document_mime_type VARCHAR(100),
    document_size BIGINT CHECK (document_size >= 0),
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    
    CONSTRAINT fk_legislation_license_type 
        FOREIGN KEY (license_type_id_fk) REFERENCES t_license_type(id) ON DELETE CASCADE,
    CONSTRAINT chk_legislation_name_not_empty 
        CHECK (LENGTH(TRIM(name)) > 0),
    CONSTRAINT chk_document_consistency 
        CHECK (
            (document_url IS NULL AND document_name IS NULL AND document_mime_type IS NULL AND document_size IS NULL) OR
            (document_url IS NOT NULL AND document_name IS NOT NULL AND document_mime_type IS NOT NULL AND document_size IS NOT NULL)
        )
);
```

### 2.3 Índices

```sql
-- Índice principal para consultas por tipo de licença
CREATE INDEX idx_legislation_license_type ON t_legislation(license_type_id_fk);

-- Índice para consultas por tipo de legislação
CREATE INDEX idx_legislation_type ON t_legislation(legislation_type);

-- Índice para consultas por status
CREATE INDEX idx_legislation_status ON t_legislation(status) WHERE status = 'ACTIVE';

-- Índice para auditoria
CREATE INDEX idx_legislation_created_at ON t_legislation(created_at DESC);

-- Índice composto para consultas filtradas
CREATE INDEX idx_legislation_type_status ON t_legislation(license_type_id_fk, legislation_type, status);

-- Índice para busca textual
CREATE INDEX idx_legislation_name_search ON t_legislation USING gin(to_tsvector('portuguese', name));
CREATE INDEX idx_legislation_description_search ON t_legislation USING gin(to_tsvector('portuguese', description));
```

## 3. Arquitetura DDD

### 3.1 Domain Layer

#### 3.1.1 Aggregate Root: Legislation

```java
@Entity
@Table(name = "t_legislation")
public class Legislation {
    @Id
    private LegislationId id;
    
    @Column(name = "license_type_id_fk", nullable = false)
    private LicenseTypeId licenseTypeId;
    
    @Column(name = "name", nullable = false)
    private String name;
    
    @Column(name = "legislation_type", nullable = false)
    private String legislationType;
    
    @Column(name = "publication_date")
    private LocalDate publicationDate;
    
    @Column(name = "republic_bulletin")
    private String republicBulletin;
    
    @Column(name = "description")
    private String description;
    
    @Embedded
    private DocumentInfo documentInfo;
    
    @Column(name = "status", nullable = false)
    private String status;
    
    // Campos de auditoria
    @Column(name = "created_at", nullable = false)
    private Instant createdAt;
    
    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;
    
    @Column(name = "created_by", nullable = false)
    private String createdBy;
    
    @Column(name = "updated_by", nullable = false)
    private String updatedBy;
    
    // Métodos de negócio
    public static Legislation create(
            LicenseTypeId licenseTypeId,
            String name,
            String legislationType,
            LocalDate publicationDate,
            String republicBulletin,
            String description,
            String createdBy,
            LegislationType legislationTypeService) {
        
        validateCreationParameters(licenseTypeId, name, legislationType, createdBy, legislationTypeService);
        
        return new Legislation(
            LegislationId.generate(),
            licenseTypeId,
            name.trim(),
            legislationType,
            publicationDate,
            republicBulletin != null ? republicBulletin.trim() : null,
            description != null ? description.trim() : null,
            null, // documentInfo será definido posteriormente
            "ACTIVE",
            Instant.now(),
            Instant.now(),
            createdBy,
            createdBy
        );
    }
    
    public void updateBasicInfo(
            String name,
            String legislationType,
            LocalDate publicationDate,
            String republicBulletin,
            String description,
            String updatedBy,
            LegislationType legislationTypeService) {
        
        validateUpdateParameters(name, legislationType, updatedBy, legislationTypeService);
        
        this.name = name.trim();
        this.legislationType = legislationType;
        this.publicationDate = publicationDate;
        this.republicBulletin = republicBulletin != null ? republicBulletin.trim() : null;
        this.description = description != null ? description.trim() : null;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }
    
    public void attachDocument(
            String documentUrl,
            String documentName,
            String mimeType,
            Long size,
            String updatedBy) {
        
        validateDocumentParameters(documentUrl, documentName, mimeType, size);
        
        this.documentInfo = new DocumentInfo(documentUrl, documentName, mimeType, size);
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }
    
    public void removeDocument(String updatedBy) {
        this.documentInfo = null;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }
    
    public void deactivate(String updatedBy) {
        this.status = "INACTIVE";
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }
    
    public void activate(String updatedBy) {
        this.status = "ACTIVE";
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }
    
    public boolean hasDocument() {
        return documentInfo != null;
    }
    
    public boolean isActive() {
        return "ACTIVE".equals(status);
    }
    
    // Validações privadas
    private static void validateCreationParameters(
            LicenseTypeId licenseTypeId,
            String name,
            String legislationType,
            String createdBy,
            LegislationType legislationTypeService) {
        
        if (licenseTypeId == null) {
            throw new DomainException("License type ID is required");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new DomainException("Legislation name is required");
        }
        if (name.trim().length() > 255) {
            throw new DomainException("Legislation name cannot exceed 255 characters");
        }
        if (legislationType == null || legislationType.trim().isEmpty()) {
            throw new DomainException("Legislation type is required");
        }
        if (!legislationTypeService.isValid(legislationType)) {
            throw new DomainException("Invalid legislation type: " + legislationType);
        }
        if (createdBy == null || createdBy.trim().isEmpty()) {
            throw new DomainException("Created by is required");
        }
    }
    
    private static void validateUpdateParameters(
            String name,
            String legislationType,
            String updatedBy,
            LegislationType legislationTypeService) {
        
        if (name == null || name.trim().isEmpty()) {
            throw new DomainException("Legislation name is required");
        }
        if (name.trim().length() > 255) {
            throw new DomainException("Legislation name cannot exceed 255 characters");
        }
        if (legislationType == null || legislationType.trim().isEmpty()) {
            throw new DomainException("Legislation type is required");
        }
        if (!legislationTypeService.isValid(legislationType)) {
            throw new DomainException("Invalid legislation type: " + legislationType);
        }
        if (updatedBy == null || updatedBy.trim().isEmpty()) {
            throw new DomainException("Updated by is required");
        }
    }
    
    private static void validateDocumentParameters(
            String documentUrl,
            String documentName,
            String mimeType,
            Long size) {
        
        if (documentUrl == null || documentUrl.trim().isEmpty()) {
            throw new DomainException("Document URL is required");
        }
        if (documentName == null || documentName.trim().isEmpty()) {
            throw new DomainException("Document name is required");
        }
        if (mimeType == null || mimeType.trim().isEmpty()) {
            throw new DomainException("Document MIME type is required");
        }
        if (size == null || size <= 0) {
            throw new DomainException("Document size must be positive");
        }
        if (size > 50 * 1024 * 1024) { // 50MB limit
            throw new DomainException("Document size cannot exceed 50MB");
        }
    }
}
```

#### 3.1.5 Domain Services

```java
@Component
public class LegislationType {
    private final OptionService optionService;
    
    public LegislationType(OptionService optionService) {
        this.optionService = optionService;
    }
    
    public List<Option> getValidOptions() {
        return optionService.findByCode("TPLEG");
    }
    
    public boolean isValid(String value) {
        return optionService.isValidOption("TPLEG", value);
    }
    
    public String getDescription(String value) {
        return optionService.getOptionDescription("TPLEG", value);
    }
    
    public List<String> getAllValidKeys() {
        return getValidOptions().stream()
            .map(Option::getKey)
            .collect(Collectors.toList());
    }
}

@Component
public class LegislationStatus {
    private final OptionService optionService;
    
    public LegislationStatus(OptionService optionService) {
        this.optionService = optionService;
    }
    
    public List<Option> getValidOptions() {
        return optionService.findByCode("LEGISLATION_STATUS");
    }
    
    public boolean isValid(String value) {
        return optionService.isValidOption("LEGISLATION_STATUS", value);
    }
    
    public boolean isActive(String value) {
        return "ACTIVE".equals(value);
    }
}
```

#### 3.1.2 Value Objects

```java
@Embeddable
public class LegislationId {
    @Column(name = "id")
    private UUID value;
    
    public static LegislationId generate() {
        return new LegislationId(UUID.randomUUID());
    }
    
    public static LegislationId of(UUID value) {
        if (value == null) {
            throw new IllegalArgumentException("LegislationId cannot be null");
        }
        return new LegislationId(value);
    }
    
    // constructors, equals, hashCode, toString
}

@Embeddable
public class DocumentInfo {
    @Column(name = "document_url")
    private String url;
    
    @Column(name = "document_name")
    private String name;
    
    @Column(name = "document_mime_type")
    private String mimeType;
    
    @Column(name = "document_size")
    private Long size;
    
    public DocumentInfo(String url, String name, String mimeType, Long size) {
        this.url = url;
        this.name = name;
        this.mimeType = mimeType;
        this.size = size;
    }
    
    public boolean isPdf() {
        return "application/pdf".equals(mimeType);
    }
    
    public boolean isImage() {
        return mimeType != null && mimeType.startsWith("image/");
    }
    
    public String getFormattedSize() {
        if (size == null) return "0 B";
        
        String[] units = {"B", "KB", "MB", "GB"};
        int unitIndex = 0;
        double fileSize = size.doubleValue();
        
        while (fileSize >= 1024 && unitIndex < units.length - 1) {
            fileSize /= 1024;
            unitIndex++;
        }
        
        return String.format("%.1f %s", fileSize, units[unitIndex]);
    }
    
    // getters, constructors, equals, hashCode
}
```

#### 3.1.3 Repository Interface

```java
public interface LegislationRepository {
    Optional<Legislation> findById(LegislationId id);
    List<Legislation> findByLicenseTypeId(LicenseTypeId licenseTypeId);
    List<Legislation> findByLicenseTypeIdAndStatus(LicenseTypeId licenseTypeId, String status);
    List<Legislation> findByLegislationType(String legislationType);
    Page<Legislation> findByLicenseTypeIdWithFilters(
        LicenseTypeId licenseTypeId,
        String legislationType,
        String status,
        String searchTerm,
        Pageable pageable
    );
    Page<Legislation> findAll(Pageable pageable);
    Legislation save(Legislation legislation);
    void delete(Legislation legislation);
    void deleteAll(List<Legislation> legislations);
    boolean existsById(LegislationId id);
    long countByLicenseTypeId(LicenseTypeId licenseTypeId);
    long countByLicenseTypeIdAndStatus(LicenseTypeId licenseTypeId, String status);
}
```

#### 3.1.6 Legislation Domain Service

```java
@Service
public class LegislationDomainService {
    
    private final LegislationRepository legislationRepository;
    private final LicenseTypeRepository licenseTypeRepository;
    private final DocumentStorageService documentStorageService;
    
    public LegislationDomainService(
            LegislationRepository legislationRepository,
            LicenseTypeRepository licenseTypeRepository,
            DocumentStorageService documentStorageService) {
        this.legislationRepository = legislationRepository;
        this.licenseTypeRepository = licenseTypeRepository;
        this.documentStorageService = documentStorageService;
    }
    
    public void validateLicenseTypeExists(LicenseTypeId licenseTypeId) {
        if (!licenseTypeRepository.existsById(licenseTypeId)) {
            throw new DomainException("License type not found: " + licenseTypeId.getValue());
        }
    }
    
    public void validateUniqueNamePerLicenseType(
            LicenseTypeId licenseTypeId,
            String name,
            LegislationId excludeId) {
        
        List<Legislation> existing = legislationRepository.findByLicenseTypeId(licenseTypeId);
        
        boolean nameExists = existing.stream()
            .filter(leg -> excludeId == null || !leg.getId().equals(excludeId))
            .anyMatch(leg -> leg.getName().equalsIgnoreCase(name.trim()));
        
        if (nameExists) {
            throw new DomainException("Legislation name already exists for this license type: " + name);
        }
    }
    
    public void validateCanDelete(List<LegislationId> legislationIds) {
        for (LegislationId id : legislationIds) {
            if (!legislationRepository.existsById(id)) {
                throw new EntityNotFoundException("Legislation not found: " + id.getValue());
            }
        }
        
        // Validações adicionais podem ser adicionadas aqui
        // Por exemplo, verificar se existem processos ativos usando estas legislações
    }
    
    public DocumentUploadResult uploadDocument(
            MultipartFile file,
            String folder) {
        
        validateDocumentFile(file);
        
        try {
            String fileName = generateUniqueFileName(file.getOriginalFilename());
            String documentUrl = documentStorageService.uploadFile(file, folder, fileName);
            
            return new DocumentUploadResult(
                documentUrl,
                fileName,
                file.getContentType(),
                file.getSize()
            );
        } catch (Exception e) {
            throw new DomainException("Failed to upload document: " + e.getMessage(), e);
        }
    }
    
    public void deleteDocument(String documentUrl) {
        try {
            documentStorageService.deleteFile(documentUrl);
        } catch (Exception e) {
            // Log error but don't fail the operation
            // Document might have been already deleted or moved
            log.warn("Failed to delete document: {}", documentUrl, e);
        }
    }
    
    private void validateDocumentFile(MultipartFile file) {
        if (file == null || file.isEmpty()) {
            throw new DomainException("Document file is required");
        }
        
        if (file.getSize() > 50 * 1024 * 1024) { // 50MB
            throw new DomainException("Document file size cannot exceed 50MB");
        }
        
        String contentType = file.getContentType();
        if (contentType == null) {
            throw new DomainException("Document file type cannot be determined");
        }
        
        List<String> allowedTypes = Arrays.asList(
            "application/pdf",
            "application/msword",
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            "image/jpeg",
            "image/png",
            "image/gif"
        );
        
        if (!allowedTypes.contains(contentType)) {
            throw new DomainException("Document file type not allowed: " + contentType);
        }
    }
    
    private String generateUniqueFileName(String originalFileName) {
        String extension = "";
        if (originalFileName != null && originalFileName.contains(".")) {
            extension = originalFileName.substring(originalFileName.lastIndexOf("."));
        }
        return UUID.randomUUID().toString() + extension;
    }
    
    public static class DocumentUploadResult {
        private final String url;
        private final String name;
        private final String mimeType;
        private final Long size;
        
        public DocumentUploadResult(String url, String name, String mimeType, Long size) {
            this.url = url;
            this.name = name;
            this.mimeType = mimeType;
            this.size = size;
        }
        
        // getters
    }
}
```

### 3.2 Application Layer

#### 3.2.1 Use Cases

```java
@UseCase
@Transactional
public class CreateLegislationUseCase {
    
    private final LegislationRepository legislationRepository;
    private final LegislationDomainService domainService;
    private final LegislationType legislationTypeService;
    
    public LegislationResponse execute(CreateLegislationCommand command) {
        // Validar tipo de licença existe
        domainService.validateLicenseTypeExists(command.getLicenseTypeId());
        
        // Validar unicidade do nome
        domainService.validateUniqueNamePerLicenseType(
            command.getLicenseTypeId(),
            command.getName(),
            null
        );
        
        // Criar legislação
        Legislation legislation = Legislation.create(
            command.getLicenseTypeId(),
            command.getName(),
            command.getLegislationType(),
            command.getPublicationDate(),
            command.getRepublicBulletin(),
            command.getDescription(),
            command.getCreatedBy(),
            legislationTypeService
        );
        
        // Upload de documento se fornecido
        if (command.getDocumentFile() != null) {
            LegislationDomainService.DocumentUploadResult uploadResult = 
                domainService.uploadDocument(
                    command.getDocumentFile(),
                    "legislations/" + command.getLicenseTypeId().getValue()
                );
            
            legislation.attachDocument(
                uploadResult.getUrl(),
                uploadResult.getName(),
                uploadResult.getMimeType(),
                uploadResult.getSize(),
                command.getCreatedBy()
            );
        }
        
        // Salvar
        Legislation saved = legislationRepository.save(legislation);
        
        return LegislationResponse.from(saved);
    }
}

@UseCase
@Transactional
public class UpdateLegislationUseCase {
    
    private final LegislationRepository legislationRepository;
    private final LegislationDomainService domainService;
    private final LegislationType legislationTypeService;
    
    public LegislationResponse execute(UpdateLegislationCommand command) {
        // Buscar legislação existente
        Legislation legislation = legislationRepository
            .findById(command.getId())
            .orElseThrow(() -> new EntityNotFoundException("Legislation not found"));
        
        // Validar unicidade do nome se alterado
        if (!legislation.getName().equals(command.getName())) {
            domainService.validateUniqueNamePerLicenseType(
                legislation.getLicenseTypeId(),
                command.getName(),
                command.getId()
            );
        }
        
        // Atualizar informações básicas
        legislation.updateBasicInfo(
            command.getName(),
            command.getLegislationType(),
            command.getPublicationDate(),
            command.getRepublicBulletin(),
            command.getDescription(),
            command.getUpdatedBy(),
            legislationTypeService
        );
        
        // Processar documento se fornecido
        if (command.getDocumentFile() != null) {
            // Remover documento anterior se existir
            if (legislation.hasDocument()) {
                domainService.deleteDocument(legislation.getDocumentInfo().getUrl());
            }
            
            // Upload novo documento
            LegislationDomainService.DocumentUploadResult uploadResult = 
                domainService.uploadDocument(
                    command.getDocumentFile(),
                    "legislations/" + legislation.getLicenseTypeId().getValue()
                );
            
            legislation.attachDocument(
                uploadResult.getUrl(),
                uploadResult.getName(),
                uploadResult.getMimeType(),
                uploadResult.getSize(),
                command.getUpdatedBy()
            );
        }
        
        // Salvar
        Legislation updated = legislationRepository.save(legislation);
        
        return LegislationResponse.from(updated);
    }
}

@UseCase
@Transactional
public class DeleteLegislationsUseCase {
    
    private final LegislationRepository legislationRepository;
    private final LegislationDomainService domainService;
    
    public void execute(DeleteLegislationsCommand command) {
        // Validar que todas as legislações existem
        domainService.validateCanDelete(command.getLegislationIds());
        
        // Buscar legislações
        List<Legislation> legislations = command.getLegislationIds().stream()
            .map(id -> legislationRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Legislation not found: " + id.getValue())))
            .collect(Collectors.toList());
        
        // Remover documentos associados
        legislations.stream()
            .filter(Legislation::hasDocument)
            .forEach(leg -> domainService.deleteDocument(leg.getDocumentInfo().getUrl()));
        
        // Deletar legislações
        legislationRepository.deleteAll(legislations);
    }
}

@UseCase
@Transactional(readOnly = true)
public class ListLegislationsUseCase {
    
    private final LegislationRepository legislationRepository;
    
    public Page<LegislationResponse> execute(ListLegislationsQuery query) {
        Page<Legislation> legislations = legislationRepository.findByLicenseTypeIdWithFilters(
            query.getLicenseTypeId(),
            query.getLegislationType(),
            query.getStatus(),
            query.getSearchTerm(),
            query.getPageable()
        );
        
        return legislations.map(LegislationResponse::from);
    }
}
```

### 4.2 Application Layer

#### 4.2.1 Use Cases

\[O código dos Use Cases já está incluído acima]

#### 4.2.2 Commands e Queries

```java
public class CreateLegislationCommand {
    @NotNull(message = "License type ID is required")
    private LicenseTypeId licenseTypeId;
    
    @NotBlank(message = "Legislation name is required")
    @Size(max = 255, message = "Legislation name cannot exceed 255 characters")
    private String name;
    
    @NotBlank(message = "Legislation type is required")
    private String legislationType;
    
    private LocalDate publicationDate;
    
    @Size(max = 100, message = "Republic bulletin cannot exceed 100 characters")
    private String republicBulletin;
    
    @Size(max = 5000, message = "Description cannot exceed 5000 characters")
    private String description;
    
    private MultipartFile documentFile;
    
    @NotBlank(message = "Created by is required")
    private String createdBy;
    
    // getters, setters, validation
}

public class UpdateLegislationCommand {
    @NotNull(message = "Legislation ID is required")
    private LegislationId id;
    
    @NotBlank(message = "Legislation name is required")
    @Size(max = 255, message = "Legislation name cannot exceed 255 characters")
    private String name;
    
    @NotBlank(message = "Legislation type is required")
    private String legislationType;
    
    private LocalDate publicationDate;
    
    @Size(max = 100, message = "Republic bulletin cannot exceed 100 characters")
    private String republicBulletin;
    
    @Size(max = 5000, message = "Description cannot exceed 5000 characters")
    private String description;
    
    private MultipartFile documentFile;
    
    @NotBlank(message = "Updated by is required")
    private String updatedBy;
    
    // getters, setters, validation
}

public class DeleteLegislationsCommand {
    @NotEmpty(message = "At least one legislation ID is required")
    private List<LegislationId> legislationIds;
    
    @NotBlank(message = "Deleted by is required")
    private String deletedBy;
    
    // getters, setters, validation
}

public class ListLegislationsQuery {
    private LicenseTypeId licenseTypeId;
    private String legislationType;
    private String status;
    private String searchTerm;
    private Pageable pageable;
    
    // getters, setters, builder
}

public class LegislationResponse {
    private UUID id;
    private UUID licenseTypeId;
    private String licenseTypeName;
    private String name;
    private String legislationType;
    private String legislationTypeDescription;
    private LocalDate publicationDate;
    private String republicBulletin;
    private String description;
    private DocumentInfoResponse documentInfo;
    private String status;
    private Instant createdAt;
    private Instant updatedAt;
    private String createdBy;
    private String updatedBy;
    
    public static LegislationResponse from(Legislation legislation) {
        return LegislationResponse.builder()
            .id(legislation.getId().getValue())
            .licenseTypeId(legislation.getLicenseTypeId().getValue())
            .name(legislation.getName())
            .legislationType(legislation.getLegislationType())
            .publicationDate(legislation.getPublicationDate())
            .republicBulletin(legislation.getRepublicBulletin())
            .description(legislation.getDescription())
            .documentInfo(legislation.hasDocument() ? 
                DocumentInfoResponse.from(legislation.getDocumentInfo()) : null)
            .status(legislation.getStatus())
            .createdAt(legislation.getCreatedAt())
            .updatedAt(legislation.getUpdatedAt())
            .createdBy(legislation.getCreatedBy())
            .updatedBy(legislation.getUpdatedBy())
            .build();
    }
}

public class DocumentInfoResponse {
    private String url;
    private String name;
    private String mimeType;
    private Long size;
    private String formattedSize;
    private boolean isPdf;
    private boolean isImage;
    
    public static DocumentInfoResponse from(DocumentInfo documentInfo) {
        return DocumentInfoResponse.builder()
            .url(documentInfo.getUrl())
            .name(documentInfo.getName())
            .mimeType(documentInfo.getMimeType())
            .size(documentInfo.getSize())
            .formattedSize(documentInfo.getFormattedSize())
            .isPdf(documentInfo.isPdf())
            .isImage(documentInfo.isImage())
            .build();
    }
}
```

## 4. APIs REST

### 4.1 Visão Geral

Este capítulo detalha todas as APIs REST disponíveis para o módulo de Gestão de Legislações, incluindo endpoints, parâmetros, exemplos de requisições e respostas.

**Base URL**: `/api/v1/legislations`

**Autenticação**: Bearer Token (JWT)

**Content-Type**:

* `application/json` (para requisições JSON)

* `multipart/form-data` (para upload de documentos)

### 4.2 Endpoints Disponíveis

#### 4.2.1 Criar Legislação

**Endpoint**: `POST /api/v1/legislations`

**Descrição**: Cria uma nova legislação associada a um tipo de licença, com possibilidade de upload de documento.

**Content-Type**: `multipart/form-data`

**Parâmetros**:

| Campo            | Tipo   | Obrigatório | Descrição                                  |
| ---------------- | ------ | ----------- | ------------------------------------------ |
| licenseTypeId    | UUID   | Sim         | ID do tipo de licença                      |
| name             | String | Sim         | Nome da legislação (máx. 255 caracteres)   |
| legislationType  | String | Sim         | Tipo de legislação (LEI, DECRETO, etc.)    |
| publicationDate  | Date   | Não         | Data de publicação (formato: yyyy-MM-dd)   |
| republicBulletin | String | Não         | Boletim da República (máx. 100 caracteres) |
| description      | String | Não         | Descrição (máx. 5000 caracteres)           |
| documentFile     | File   | Não         | Arquivo do documento (máx. 50MB)           |

**Exemplo de Requisição (curl)**:

```bash
curl -X POST "http://localhost:8080/api/v1/legislations" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -F "licenseTypeId=550e8400-e29b-41d4-a716-446655440000" \
  -F "name=Lei de Licenciamento Comercial" \
  -F "legislationType=LEI" \
  -F "publicationDate=2023-06-15" \
  -F "republicBulletin=BR Nº 35/2023" \
  -F "description=Lei que estabelece o regime jurídico do exercício da atividade comercial" \
  -F "documentFile=@/path/to/lei_comercial.pdf"
```

**Resposta de Sucesso (201 Created)**:

```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "licenseTypeId": "550e8400-e29b-41d4-a716-446655440000",
  "name": "Lei de Licenciamento Comercial",
  "legislationType": "LEI",
  "publicationDate": "2023-06-15",
  "republicBulletin": "BR Nº 35/2023",
  "description": "Lei que estabelece o regime jurídico do exercício da atividade comercial",
  "status": "ACTIVE",
  "documentInfo": {
    "url": "http://minio.example.com/documents/legislations/123e4567-e89b-12d3-a456-426614174000/lei_comercial.pdf",
    "name": "lei_comercial.pdf",
    "mimeType": "application/pdf",
    "size": 2048576
  },
  "createdAt": "2023-06-15T10:30:00Z",
  "updatedAt": "2023-06-15T10:30:00Z",
  "createdBy": "user@example.com",
  "updatedBy": "user@example.com"
}
```

**Códigos de Erro**:

* `400 Bad Request`: Dados inválidos ou ausentes

* `401 Unauthorized`: Token de autenticação inválido

* `404 Not Found`: Tipo de licença não encontrado

* `409 Conflict`: Nome da legislação já existe para este tipo de licença

* `413 Payload Too Large`: Arquivo muito grande (>50MB)

* `415 Unsupported Media Type`: Tipo de arquivo não suportado

**Exemplo de Erro (400 Bad Request)**:

```json
{
  "timestamp": "2023-06-15T10:30:00Z",
  "status": 400,
  "error": "Bad Request",
  "message": "Validation failed",
  "path": "/api/v1/legislations",
  "details": [
    {
      "field": "name",
      "message": "Legislation name is required"
    },
    {
      "field": "legislationType",
      "message": "Invalid legislation type: INVALID_TYPE"
    }
  ]
}
```

#### 4.2.2 Obter Legislação por ID

**Endpoint**: `GET /api/v1/legislations/{id}`

**Descrição**: Obtém os detalhes de uma legislação específica.

**Parâmetros**:

* `id` (Path): UUID da legislação

**Exemplo de Requisição**:

```bash
curl -X GET "http://localhost:8080/api/v1/legislations/123e4567-e89b-12d3-a456-426614174000" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**Resposta de Sucesso (200 OK)**:

```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "licenseTypeId": "550e8400-e29b-41d4-a716-446655440000",
  "name": "Lei de Licenciamento Comercial",
  "legislationType": "LEI",
  "publicationDate": "2023-06-15",
  "republicBulletin": "BR Nº 35/2023",
  "description": "Lei que estabelece o regime jurídico do exercício da atividade comercial",
  "status": "ACTIVE",
  "documentInfo": {
    "url": "http://minio.example.com/documents/legislations/123e4567-e89b-12d3-a456-426614174000/lei_comercial.pdf",
    "name": "lei_comercial.pdf",
    "mimeType": "application/pdf",
    "size": 2048576
  },
  "createdAt": "2023-06-15T10:30:00Z",
  "updatedAt": "2023-06-15T10:30:00Z",
  "createdBy": "user@example.com",
  "updatedBy": "user@example.com"
}
```

**Códigos de Erro**:

* `401 Unauthorized`: Token de autenticação inválido

* `404 Not Found`: Legislação não encontrada

#### 4.2.3 Listar Legislações

**Endpoint**: `GET /api/v1/legislations`

**Descrição**: Lista legislações com filtros e paginação.

**Parâmetros de Query**:

| Parâmetro       | Tipo    | Obrigatório | Descrição                                   |
| --------------- | ------- | ----------- | ------------------------------------------- |
| licenseTypeId   | UUID    | Não         | Filtrar por tipo de licença                 |
| legislationType | String  | Não         | Filtrar por tipo de legislação              |
| status          | String  | Não         | Filtrar por status (ACTIVE, INACTIVE)       |
| search          | String  | Não         | Busca textual no nome e descrição           |
| page            | Integer | Não         | Número da página (padrão: 0)                |
| size            | Integer | Não         | Tamanho da página (padrão: 20)              |
| sort            | String  | Não         | Campo de ordenação (padrão: createdAt,desc) |

**Exemplo de Requisição**:

```bash
curl -X GET "http://localhost:8080/api/v1/legislations?licenseTypeId=550e8400-e29b-41d4-a716-446655440000&legislationType=LEI&status=ACTIVE&search=comercial&page=0&size=10&sort=name,asc" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**Resposta de Sucesso (200 OK)**:

```json
{
  "content": [
    {
      "id": "123e4567-e89b-12d3-a456-426614174000",
      "licenseTypeId": "550e8400-e29b-41d4-a716-446655440000",
      "name": "Lei de Licenciamento Comercial",
      "legislationType": "LEI",
      "publicationDate": "2023-06-15",
      "republicBulletin": "BR Nº 35/2023",
      "description": "Lei que estabelece o regime jurídico do exercício da atividade comercial",
      "status": "ACTIVE",
      "documentInfo": {
        "url": "http://minio.example.com/documents/legislations/123e4567-e89b-12d3-a456-426614174000/lei_comercial.pdf",
        "name": "lei_comercial.pdf",
        "mimeType": "application/pdf",
        "size": 2048576
      },
      "createdAt": "2023-06-15T10:30:00Z",
      "updatedAt": "2023-06-15T10:30:00Z",
      "createdBy": "user@example.com",
      "updatedBy": "user@example.com"
    }
  ],
  "pageable": {
    "sort": {
      "sorted": true,
      "unsorted": false
    },
    "pageNumber": 0,
    "pageSize": 10,
    "offset": 0,
    "paged": true,
    "unpaged": false
  },
  "totalElements": 1,
  "totalPages": 1,
  "last": true,
  "first": true,
  "numberOfElements": 1,
  "size": 10,
  "number": 0,
  "sort": {
    "sorted": true,
    "unsorted": false
  },
  "empty": false
}
```

#### 4.2.4 Atualizar Legislação

**Endpoint**: `PUT /api/v1/legislations/{id}`

**Descrição**: Atualiza uma legislação existente, incluindo possibilidade de substituir o documento.

**Content-Type**: `multipart/form-data`

**Parâmetros**:

* `id` (Path): UUID da legislação

* Campos do formulário (mesmos da criação, exceto licenseTypeId)

**Exemplo de Requisição**:

```bash
curl -X PUT "http://localhost:8080/api/v1/legislations/123e4567-e89b-12d3-a456-426614174000" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -F "name=Lei de Licenciamento Comercial Atualizada" \
  -F "legislationType=LEI" \
  -F "publicationDate=2023-06-15" \
  -F "republicBulletin=BR Nº 35/2023" \
  -F "description=Lei atualizada que estabelece o regime jurídico do exercício da atividade comercial" \
  -F "documentFile=@/path/to/lei_comercial_v2.pdf"
```

**Resposta de Sucesso (200 OK)**:

```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "licenseTypeId": "550e8400-e29b-41d4-a716-446655440000",
  "name": "Lei de Licenciamento Comercial Atualizada",
  "legislationType": "LEI",
  "publicationDate": "2023-06-15",
  "republicBulletin": "BR Nº 35/2023",
  "description": "Lei atualizada que estabelece o regime jurídico do exercício da atividade comercial",
  "status": "ACTIVE",
  "documentInfo": {
    "url": "http://minio.example.com/documents/legislations/123e4567-e89b-12d3-a456-426614174000/lei_comercial_v2.pdf",
    "name": "lei_comercial_v2.pdf",
    "mimeType": "application/pdf",
    "size": 2150000
  },
  "createdAt": "2023-06-15T10:30:00Z",
  "updatedAt": "2023-06-15T14:45:00Z",
  "createdBy": "user@example.com",
  "updatedBy": "user@example.com"
}
```

#### 4.2.5 Eliminar Legislação

**Endpoint**: `DELETE /api/v1/legislations/{id}`

**Descrição**: Remove uma legislação específica.

**Parâmetros**:

* `id` (Path): UUID da legislação

**Exemplo de Requisição**:

```bash
curl -X DELETE "http://localhost:8080/api/v1/legislations/123e4567-e89b-12d3-a456-426614174000" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**Resposta de Sucesso (204 No Content)**:

```
(Sem conteúdo)
```

#### 4.2.6 Eliminar Múltiplas Legislações

**Endpoint**: `DELETE /api/v1/legislations`

**Descrição**: Remove múltiplas legislações em uma única operação.

**Content-Type**: `application/json`

**Body**:

```json
{
  "ids": [
    "123e4567-e89b-12d3-a456-426614174000",
    "456e7890-e89b-12d3-a456-426614174001"
  ]
}
```

**Exemplo de Requisição**:

```bash
curl -X DELETE "http://localhost:8080/api/v1/legislations" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -H "Content-Type: application/json" \
  -d '{
    "ids": [
      "123e4567-e89b-12d3-a456-426614174000",
      "456e7890-e89b-12d3-a456-426614174001"
    ]
  }'
```

**Resposta de Sucesso (204 No Content)**:

```
(Sem conteúdo)
```

#### 4.2.7 Listar por Tipo de Licença

**Endpoint**: `GET /api/v1/legislations/license-type/{licenseTypeId}`

**Descrição**: Lista legislações de um tipo de licença específico.

**Parâmetros**:

* `licenseTypeId` (Path): UUID do tipo de licença

* Parâmetros de query (mesmos da listagem geral, exceto licenseTypeId)

**Exemplo de Requisição**:

```bash
curl -X GET "http://localhost:8080/api/v1/legislations/license-type/550e8400-e29b-41d4-a716-446655440000?legislationType=LEI&status=ACTIVE" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**Resposta**: Mesma estrutura da listagem geral.

#### 4.2.8 Obter Tipos de Legislação

**Endpoint**: `GET /api/v1/legislations/options/legislation-types`

**Descrição**: Obtém a lista de tipos de legislação disponíveis (da tabela t\_options).

**Exemplo de Requisição**:

```bash
curl -X GET "http://localhost:8080/api/v1/legislations/options/legislation-types" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**Resposta de Sucesso (200 OK)**:

```json
[
  {
    "id": "789e0123-e89b-12d3-a456-426614174000",
    "ccode": "TPLEG",
    "ckey": "LEI",
    "cvalue": "Lei",
    "description": "Lei aprovada pelo parlamento",
    "sortOrder": 2,
    "active": true
  },
  {
    "id": "789e0123-e89b-12d3-a456-426614174001",
    "ccode": "TPLEG",
    "ckey": "DECRETO",
    "cvalue": "Decreto",
    "description": "Decreto governamental",
    "sortOrder": 1,
    "active": true
  },
  {
    "id": "789e0123-e89b-12d3-a456-426614174002",
    "ccode": "TPLEG",
    "ckey": "REGULAMENTO",
    "cvalue": "Regulamento",
    "description": "Regulamento administrativo",
    "sortOrder": 3,
    "active": true
  }
]
```

#### 4.2.9 Download de Documento

**Endpoint**: `GET /api/v1/legislations/download/{id}`

**Descrição**: Faz o download do documento associado à legislação.

**Parâmetros**:

* `id` (Path): UUID da legislação

**Exemplo de Requisição**:

```bash
curl -X GET "http://localhost:8080/api/v1/legislations/download/123e4567-e89b-12d3-a456-426614174000" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -o "lei_comercial.pdf"
```

**Resposta de Sucesso (200 OK)**:

* **Content-Type**: Tipo MIME do arquivo (ex: `application/pdf`)

* **Content-Disposition**: `attachment; filename="lei_comercial.pdf"`

* **Body**: Conteúdo binário do arquivo

**Códigos de Erro**:

* `404 Not Found`: Legislação não encontrada ou sem documento associado

### 4.3 Estruturas de Dados

#### 4.3.1 LegislationResponse

```json
{
  "id": "UUID",
  "licenseTypeId": "UUID",
  "name": "String",
  "legislationType": "String",
  "publicationDate": "Date (yyyy-MM-dd)",
  "republicBulletin": "String",
  "description": "String",
  "status": "String",
  "documentInfo": {
    "url": "String",
    "name": "String",
    "mimeType": "String",
    "size": "Long"
  },
  "createdAt": "DateTime (ISO 8601)",
  "updatedAt": "DateTime (ISO 8601)",
  "createdBy": "String",
  "updatedBy": "String"
}
```

#### 4.3.2 OptionResponse

```json
{
  "id": "UUID",
  "ccode": "String",
  "ckey": "String",
  "cvalue": "String",
  "description": "String",
  "sortOrder": "Integer",
  "active": "Boolean"
}
```

### 4.4 Validações e Regras de Negócio

#### 4.4.1 Validações de Entrada

* **Nome da Legislação**: Obrigatório, máximo 255 caracteres, único por tipo de licença

* **Tipo de Legislação**: Obrigatório, deve existir na tabela t\_options com ccode='TPLEG'

* **Data de Publicação**: Formato yyyy-MM-dd, não pode ser futura

* **Boletim da República**: Máximo 100 caracteres

* **Descrição**: Máximo 5000 caracteres

* **Arquivo de Documento**: Máximo 50MB, tipos permitidos: PDF, DOC, DOCX, JPG, PNG, GIF

#### 4.4.2 Regras de Negócio

* Uma legislação só pode ser associada a um tipo de licença existente

* O nome da legislação deve ser único dentro do mesmo tipo de licença

* Ao atualizar uma legislação com novo documento, o documento anterior é substituído

* A eliminação de uma legislação também remove o documento associado do armazenamento

* Legislações podem ser filtradas por status (ACTIVE/INACTIVE)

* A busca textual funciona nos campos nome e descrição

### 4.5 Códigos de Status HTTP

| Código | Descrição              | Quando Ocorre                             |
| ------ | ---------------------- | ----------------------------------------- |
| 200    | OK                     | Operação bem-sucedida (GET, PUT)          |
| 201    | Created                | Legislação criada com sucesso             |
| 204    | No Content             | Legislação eliminada com sucesso          |
| 400    | Bad Request            | Dados de entrada inválidos                |
| 401    | Unauthorized           | Token de autenticação ausente ou inválido |
| 403    | Forbidden              | Usuário sem permissão para a operação     |
| 404    | Not Found              | Recurso não encontrado                    |
| 409    | Conflict               | Conflito (ex: nome duplicado)             |
| 413    | Payload Too Large      | Arquivo muito grande                      |
| 415    | Unsupported Media Type | Tipo de arquivo não suportado             |
| 500    | Internal Server Error  | Erro interno do servidor                  |

### 4.6 Implementação do Controller

```java
@RestController
@RequestMapping("/api/v1/legislations")
@Validated
public class LegislationController {
    
    private final CreateLegislationUseCase createUseCase;
    private final UpdateLegislationUseCase updateUseCase;
    private final GetLegislationUseCase getUseCase;
    private final ListLegislationsUseCase listUseCase;
    private final DeleteLegislationsUseCase deleteUseCase;
    private final LegislationType legislationTypeService;
    
    @PostMapping(consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @ResponseStatus(HttpStatus.CREATED)
    public ResponseEntity<LegislationResponse> create(
            @Valid @ModelAttribute CreateLegislationRequest request) {
        
        CreateLegislationCommand command = CreateLegislationCommand.builder()
            .licenseTypeId(LicenseTypeId.of(request.getLicenseTypeId()))
            .name(request.getName())
            .legislationType(request.getLegislationType())
            .publicationDate(request.getPublicationDate())
            .republicBulletin(request.getRepublicBulletin())
            .description(request.getDescription())
            .documentFile(request.getDocumentFile())
            .createdBy(getCurrentUser())
            .build();
        
        LegislationResponse response = createUseCase.execute(command);
        
        return ResponseEntity.created(
            URI.create("/api/v1/legislations/" + response.getId())
        ).body(response);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<LegislationResponse> getById(@PathVariable UUID id) {
        GetLegislationQuery query = new GetLegislationQuery(LegislationId.of(id));
        LegislationResponse response = getUseCase.execute(query);
        return ResponseEntity.ok(response);
    }
    
    @GetMapping
    public ResponseEntity<Page<LegislationResponse>> list(
            @RequestParam(required = false) UUID licenseTypeId,
            @RequestParam(required = false) String legislationType,
            @RequestParam(required = false) String status,
            @RequestParam(required = false) String search,
            @PageableDefault(size = 20, sort = "createdAt", direction = Sort.Direction.DESC) Pageable pageable) {
        
        ListLegislationsQuery query = ListLegislationsQuery.builder()
            .licenseTypeId(licenseTypeId != null ? LicenseTypeId.of(licenseTypeId) : null)
            .legislationType(legislationType)
            .status(status)
            .searchTerm(search)
            .pageable(pageable)
            .build();
        
        Page<LegislationResponse> response = listUseCase.execute(query);
        return ResponseEntity.ok(response);
    }
    
    @PutMapping(value = "/{id}", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<LegislationResponse> update(
            @PathVariable UUID id,
            @Valid @ModelAttribute UpdateLegislationRequest request) {
        
        UpdateLegislationCommand command = UpdateLegislationCommand.builder()
            .id(LegislationId.of(id))
            .name(request.getName())
            .legislationType(request.getLegislationType())
            .publicationDate(request.getPublicationDate())
            .republicBulletin(request.getRepublicBulletin())
            .description(request.getDescription())
            .documentFile(request.getDocumentFile())
            .updatedBy(getCurrentUser())
            .build();
        
        LegislationResponse response = updateUseCase.execute(command);
        return ResponseEntity.ok(response);
    }
    
    @DeleteMapping
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public ResponseEntity<Void> deleteMultiple(@RequestBody DeleteLegislationsRequest request) {
        List<LegislationId> legislationIds = request.getIds().stream()
            .map(LegislationId::of)
            .collect(Collectors.toList());
        
        DeleteLegislationsCommand command = new DeleteLegislationsCommand(
            legislationIds,
            getCurrentUser()
        );
        
        deleteUseCase.execute(command);
        return ResponseEntity.noContent().build();
    }
    
    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public ResponseEntity<Void> delete(@PathVariable UUID id) {
        DeleteLegislationsCommand command = new DeleteLegislationsCommand(
            Arrays.asList(LegislationId.of(id)),
            getCurrentUser()
        );
        
        deleteUseCase.execute(command);
        return ResponseEntity.noContent().build();
    }
    
    @GetMapping("/license-type/{licenseTypeId}")
    public ResponseEntity<Page<LegislationResponse>> getByLicenseType(
            @PathVariable UUID licenseTypeId,
            @RequestParam(required = false) String legislationType,
            @RequestParam(required = false) String status,
            @RequestParam(required = false) String search,
            @PageableDefault(size = 20, sort = "createdAt", direction = Sort.Direction.DESC) Pageable pageable) {
        
        ListLegislationsQuery query = ListLegislationsQuery.builder()
            .licenseTypeId(LicenseTypeId.of(licenseTypeId))
            .legislationType(legislationType)
            .status(status)
            .searchTerm(search)
            .pageable(pageable)
            .build();
        
        Page<LegislationResponse> response = listUseCase.execute(query);
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/options/legislation-types")
    public ResponseEntity<List<OptionResponse>> getLegislationTypes() {
        List<Option> options = legislationTypeService.getValidOptions();
        List<OptionResponse> response = options.stream()
            .map(OptionResponse::from)
            .collect(Collectors.toList());
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/download/{id}")
    public ResponseEntity<Resource> downloadDocument(@PathVariable UUID id) {
        GetLegislationQuery query = new GetLegislationQuery(LegislationId.of(id));
        LegislationResponse legislation = getUseCase.execute(query);
        
        if (legislation.getDocumentInfo() == null) {
            return ResponseEntity.notFound().build();
        }
        
        try {
            Resource resource = documentStorageService.getFileAsResource(legislation.getDocumentInfo().getUrl());
            
            return ResponseEntity.ok()
                .contentType(MediaType.parseMediaType(legislation.getDocumentInfo().getMimeType()))
                .header(HttpHeaders.CONTENT_DISPOSITION, 
                    "attachment; filename=\"" + legislation.getDocumentInfo().getName() + "\"")
                .body(resource);
        } catch (Exception e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    private String getCurrentUser() {
        // Implementar lógica para obter usuário atual do contexto de segurança
        return "current-user";
    }
}
```

### 4.3 Infrastructure Layer

#### 4.3.1 REST Controller

\[O código do LegislationController já está incluído acima]

#### 4.3.2 DTOs de Request

```java
public class CreateLegislationRequest {
    @NotNull(message = "License type ID is required")
    private UUID licenseTypeId;
    
    @NotBlank(message = "Legislation name is required")
    @Size(max = 255, message = "Legislation name cannot exceed 255 characters")
    private String name;
    
    @NotBlank(message = "Legislation type is required")
    private String legislationType;
    
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private LocalDate publicationDate;
    
    @Size(max = 100, message = "Republic bulletin cannot exceed 100 characters")
    private String republicBulletin;
    
    @Size(max = 5000, message = "Description cannot exceed 5000 characters")
    private String description;
    
    private MultipartFile documentFile;
    
    // getters e setters
}

public class UpdateLegislationRequest {
    @NotBlank(message = "Legislation name is required")
    @Size(max = 255, message = "Legislation name cannot exceed 255 characters")
    private String name;
    
    @NotBlank(message = "Legislation type is required")
    private String legislationType;
    
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private LocalDate publicationDate;
    
    @Size(max = 100, message = "Republic bulletin cannot exceed 100 characters")
    private String republicBulletin;
    
    @Size(max = 5000, message = "Description cannot exceed 5000 characters")
    private String description;
    
    private MultipartFile documentFile;
    
    // getters e setters
}

public class DeleteLegislationsRequest {
    @NotEmpty(message = "At least one legislation ID is required")
    private List<UUID> ids;
    
    // getters e setters
}
```

#### 4.3.3 Document Storage Service

```java
public interface DocumentStorageService {
    String uploadFile(MultipartFile file, String folder, String fileName) throws IOException;
    void deleteFile(String fileUrl) throws IOException;
    Resource getFileAsResource(String fileUrl) throws IOException;
    String generatePresignedUrl(String fileUrl, Duration expiration);
    boolean fileExists(String fileUrl);
}

@Service
public class MinioDocumentStorageService implements DocumentStorageService {
    
    private final MinioClient minioClient;
    private final String bucketName;
    private final String baseUrl;
    
    public MinioDocumentStorageService(
            MinioClient minioClient,
            @Value("${app.minio.bucket-name}") String bucketName,
            @Value("${app.minio.base-url}") String baseUrl) {
        this.minioClient = minioClient;
        this.bucketName = bucketName;
        this.baseUrl = baseUrl;
    }
    
    @Override
    public String uploadFile(MultipartFile file, String folder, String fileName) throws IOException {
        try {
            String objectName = folder + "/" + fileName;
            
            minioClient.putObject(
                PutObjectArgs.builder()
                    .bucket(bucketName)
                    .object(objectName)
                    .stream(file.getInputStream(), file.getSize(), -1)
                    .contentType(file.getContentType())
                    .build()
            );
            
            return baseUrl + "/" + bucketName + "/" + objectName;
        } catch (Exception e) {
            throw new IOException("Failed to upload file to Minio", e);
        }
    }
    
    @Override
    public void deleteFile(String fileUrl) throws IOException {
        try {
            String objectName = extractObjectNameFromUrl(fileUrl);
            
            minioClient.removeObject(
                RemoveObjectArgs.builder()
                    .bucket(bucketName)
                    .object(objectName)
                    .build()
            );
        } catch (Exception e) {
            throw new IOException("Failed to delete file from Minio", e);
        }
    }
    
    @Override
    public Resource getFileAsResource(String fileUrl) throws IOException {
        try {
            String objectName = extractObjectNameFromUrl(fileUrl);
            
            InputStream inputStream = minioClient.getObject(
                GetObjectArgs.builder()
                    .bucket(bucketName)
                    .object(objectName)
                    .build()
            );
            
            return new InputStreamResource(inputStream);
        } catch (Exception e) {
            throw new IOException("Failed to get file from Minio", e);
        }
    }
    
    @Override
    public String generatePresignedUrl(String fileUrl, Duration expiration) {
        try {
            String objectName = extractObjectNameFromUrl(fileUrl);
            
            return minioClient.getPresignedObjectUrl(
                GetPresignedObjectUrlArgs.builder()
                    .method(Method.GET)
                    .bucket(bucketName)
                    .object(objectName)
                    .expiry((int) expiration.getSeconds())
                    .build()
            );
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate presigned URL", e);
        }
    }
    
    @Override
    public boolean fileExists(String fileUrl) {
        try {
            String objectName = extractObjectNameFromUrl(fileUrl);
            
            minioClient.statObject(
                StatObjectArgs.builder()
                    .bucket(bucketName)
                    .object(objectName)
                    .build()
            );
            
            return true;
        } catch (Exception e) {
            return false;
        }
    }
    
    private String extractObjectNameFromUrl(String fileUrl) {
        // Extract object name from full URL
        // Example: http://localhost:9000/documents/legislations/uuid/file.pdf -> legislations/uuid/file.pdf
        String prefix = baseUrl + "/" + bucketName + "/";
        if (fileUrl.startsWith(prefix)) {
            return fileUrl.substring(prefix.length());
        }
        throw new IllegalArgumentException("Invalid file URL: " + fileUrl);
    }
}
```

#### 4.3.4 Configuração Minio

```java
@Configuration
@EnableConfigurationProperties(MinioProperties.class)
public class MinioConfig {
    
    @Bean
    public MinioClient minioClient(MinioProperties properties) {
        return MinioClient.builder()
            .endpoint(properties.getUrl())
            .credentials(properties.getAccessKey(), properties.getSecretKey())
            .build();
    }
}

@ConfigurationProperties(prefix = "app.minio")
@Data
public class MinioProperties {
    private String url;
    private String accessKey;
    private String secretKey;
    private String bucketName;
    private String baseUrl;
}
```

## 5. Scripts de Migração

### 5.1 Flyway Migration - V006\_\_Create\_Legislation\_Table.sql

```sql
-- Criar tabela de legislações
CREATE TABLE t_legislation (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_type_id_fk UUID NOT NULL,
    name VARCHAR(255) NOT NULL,
    legislation_type VARCHAR(50) NOT NULL,
    publication_date DATE,
    republic_bulletin VARCHAR(100),
    description TEXT,
    document_url VARCHAR(500),
    document_name VARCHAR(255),
    document_mime_type VARCHAR(100),
    document_size BIGINT CHECK (document_size >= 0),
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    
    CONSTRAINT fk_legislation_license_type 
        FOREIGN KEY (license_type_id_fk) REFERENCES t_license_type(id) ON DELETE CASCADE,
    CONSTRAINT chk_legislation_name_not_empty 
        CHECK (LENGTH(TRIM(name)) > 0),
    CONSTRAINT chk_document_consistency 
        CHECK (
            (document_url IS NULL AND document_name IS NULL AND document_mime_type IS NULL AND document_size IS NULL) OR
            (document_url IS NOT NULL AND document_name IS NOT NULL AND document_mime_type IS NOT NULL AND document_size IS NOT NULL)
        )
);

-- Comentários na tabela
COMMENT ON TABLE t_legislation IS 'Legislações e documentos normativos associados aos tipos de licença';
COMMENT ON COLUMN t_legislation.legislation_type IS 'Tipo de legislação (Decreto, Lei, Regulamento, etc.)';
COMMENT ON COLUMN t_legislation.publication_date IS 'Data de publicação da legislação';
COMMENT ON COLUMN t_legislation.republic_bulletin IS 'Boletim da República onde foi publicada';
COMMENT ON COLUMN t_legislation.document_url IS 'URL do documento armazenado no Minio';
COMMENT ON COLUMN t_legislation.document_size IS 'Tamanho do documento em bytes';
```

### 5.2 Flyway Migration - V007\_\_Create\_Legislation\_Indexes.sql

```sql
-- Índices para performance
CREATE INDEX idx_legislation_license_type ON t_legislation(license_type_id_fk);
CREATE INDEX idx_legislation_type ON t_legislation(legislation_type);
CREATE INDEX idx_legislation_status ON t_legislation(status) WHERE status = 'ACTIVE';
CREATE INDEX idx_legislation_created_at ON t_legislation(created_at DESC);
CREATE INDEX idx_legislation_type_status ON t_legislation(license_type_id_fk, legislation_type, status);
CREATE INDEX idx_legislation_publication_date ON t_legislation(publication_date DESC) WHERE publication_date IS NOT NULL;

-- Índices para busca textual
CREATE INDEX idx_legislation_name_search ON t_legislation USING gin(to_tsvector('portuguese', name));
CREATE INDEX idx_legislation_description_search ON t_legislation USING gin(to_tsvector('portuguese', description)) WHERE description IS NOT NULL;

-- Índice único para evitar nomes duplicados por tipo de licença
CREATE UNIQUE INDEX uk_legislation_name_license_type 
    ON t_legislation(license_type_id_fk, LOWER(TRIM(name))) 
    WHERE status = 'ACTIVE';
```

### 5.3 Flyway Migration - V008\_\_Create\_Legislation\_Triggers.sql

```sql
-- Trigger para atualizar updated_at automaticamente
CREATE OR REPLACE FUNCTION update_legislation_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_legislation_updated_at
    BEFORE UPDATE ON t_legislation
    FOR EACH ROW
    EXECUTE FUNCTION update_legislation_updated_at();

-- Trigger para validação de consistência de documentos
CREATE OR REPLACE FUNCTION validate_legislation_document_consistency()
RETURNS TRIGGER AS $$
BEGIN
    -- Validar que se um campo de documento está preenchido, todos devem estar
    IF (NEW.document_url IS NOT NULL OR NEW.document_name IS NOT NULL OR 
        NEW.document_mime_type IS NOT NULL OR NEW.document_size IS NOT NULL) THEN
        
        IF (NEW.document_url IS NULL OR NEW.document_name IS NULL OR 
            NEW.document_mime_type IS NULL OR NEW.document_size IS NULL) THEN
            RAISE EXCEPTION 'All document fields must be provided together or all must be null';
        END IF;
        
        -- Validar tamanho do documento
        IF NEW.document_size <= 0 THEN
            RAISE EXCEPTION 'Document size must be positive';
        END IF;
        
        -- Validar tamanho máximo (50MB)
        IF NEW.document_size > 52428800 THEN
            RAISE EXCEPTION 'Document size cannot exceed 50MB';
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_legislation_document_consistency
    BEFORE INSERT OR UPDATE ON t_legislation
    FOR EACH ROW
    EXECUTE FUNCTION validate_legislation_document_consistency();

-- Trigger para log de auditoria
CREATE OR REPLACE FUNCTION log_legislation_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'DELETE' THEN
        INSERT INTO audit_log (table_name, operation, record_id, old_values, changed_by, changed_at)
        VALUES ('t_legislation', 'DELETE', OLD.id::text, row_to_json(OLD), OLD.updated_by, NOW());
        RETURN OLD;
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_log (table_name, operation, record_id, old_values, new_values, changed_by, changed_at)
        VALUES ('t_legislation', 'UPDATE', NEW.id::text, row_to_json(OLD), row_to_json(NEW), NEW.updated_by, NOW());
        RETURN NEW;
    ELSIF TG_OP = 'INSERT' THEN
        INSERT INTO audit_log (table_name, operation, record_id, new_values, changed_by, changed_at)
        VALUES ('t_legislation', 'INSERT', NEW.id::text, row_to_json(NEW), NEW.created_by, NOW());
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Criar tabela de auditoria se não existir
CREATE TABLE IF NOT EXISTS audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    table_name VARCHAR(100) NOT NULL,
    operation VARCHAR(10) NOT NULL,
    record_id VARCHAR(100) NOT NULL,
    old_values JSONB,
    new_values JSONB,
    changed_by VARCHAR(100) NOT NULL,
    changed_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE TRIGGER tr_legislation_audit
    AFTER INSERT OR UPDATE OR DELETE ON t_legislation
    FOR EACH ROW
    EXECUTE FUNCTION log_legislation_changes();
```

### 5.4 Dados Iniciais t\_options - V009\_\_Insert\_Legislation\_Options.sql

```sql
-- Inserir opções para TIPOS DE LEGISLAÇÃO (TPLEG)
INSERT INTO t_options (ccode, ckey, cvalue, locale, sort_order, active, description, created_by, updated_by)
VALUES 
    ('TPLEG', 'DECRETO', 'Decreto', 'pt_CV', 1, true, 'Decreto governamental', 'SYSTEM', 'SYSTEM'),
    ('TPLEG', 'LEI', 'Lei', 'pt_CV', 2, true, 'Lei aprovada pelo parlamento', 'SYSTEM', 'SYSTEM'),
    ('TPLEG', 'REGULAMENTO', 'Regulamento', 'pt_CV', 3, true, 'Regulamento administrativo', 'SYSTEM', 'SYSTEM'),
    ('TPLEG', 'PORTARIA', 'Portaria', 'pt_CV', 4, true, 'Portaria ministerial', 'SYSTEM', 'SYSTEM'),
    ('TPLEG', 'DESPACHO', 'Despacho', 'pt_CV', 5, true, 'Despacho administrativo', 'SYSTEM', 'SYSTEM'),
    ('TPLEG', 'RESOLUCAO', 'Resolução', 'pt_CV', 6, true, 'Resolução do Conselho de Ministros', 'SYSTEM', 'SYSTEM')
ON CONFLICT (ccode, ckey, locale) DO NOTHING;

-- Inserir opções para STATUS de legislações
INSERT INTO t_options (ccode, ckey, cvalue, locale, sort_order, active, description, created_by, updated_by)
VALUES 
    ('LEGISLATION_STATUS', 'ACTIVE', 'Ativo', 'pt_CV', 1, true, 'Legislação ativa e em vigor', 'SYSTEM', 'SYSTEM'),
    ('LEGISLATION_STATUS', 'INACTIVE', 'Inativo', 'pt_CV', 2, true, 'Legislação inativa ou revogada', 'SYSTEM', 'SYSTEM'),
    ('LEGISLATION_STATUS', 'DRAFT', 'Rascunho', 'pt_CV', 3, true, 'Legislação em rascunho', 'SYSTEM', 'SYSTEM')
ON CONFLICT (ccode, ckey, locale) DO NOTHING;
```

### 5.5 Dados Iniciais - V010\_\_Insert\_Legislation\_Sample\_Data.sql

```sql
-- Inserir legislações de exemplo para tipos de licença existentes
-- (Assumindo que já existem tipos de licença na tabela t_license_type)

-- Legislação para Licença de Comércio Geral
INSERT INTO t_legislation (
    license_type_id_fk,
    name,
    legislation_type,
    publication_date,
    republic_bulletin,
    description,
    status,
    created_by,
    updated_by
)
SELECT 
    lt.id,
    'Código Comercial de Cabo Verde',
    'LEI',
    '2019-06-15'::date,
    'BR Nº 35/2019',
    'Lei que estabelece o regime jurídico do exercício da atividade comercial',
    'ACTIVE',
    'SYSTEM',
    'SYSTEM'
FROM t_license_type lt 
WHERE lt.name ILIKE '%comércio%' 
LIMIT 1;

-- Legislação para Licença Industrial
INSERT INTO t_legislation (
    license_type_id_fk,
    name,
    legislation_type,
    publication_date,
    republic_bulletin,
    description,
    status,
    created_by,
    updated_by
)
SELECT 
    lt.id,
    'Regulamento de Licenciamento Industrial',
    'REGULAMENTO',
    '2020-03-10'::date,
    'BR Nº 15/2020',
    'Regulamento que define os procedimentos para licenciamento de atividades industriais',
    'ACTIVE',
    'SYSTEM',
    'SYSTEM'
FROM t_license_type lt 
WHERE lt.name ILIKE '%industrial%' 
LIMIT 1;
```

## 6. Testes

### 6.1 Testes Unitários

```java
@ExtendWith(MockitoExtension.class)
class LegislationTest {
    
    @Mock
    private LegislationType legislationTypeService;
    
    @Test
    void shouldCreateLegislationSuccessfully() {
        // Given
        LicenseTypeId licenseTypeId = LicenseTypeId.generate();
        String name = "Test Legislation";
        String legislationType = "LEI";
        String createdBy = "test-user";
        
        when(legislationTypeService.isValid(legislationType)).thenReturn(true);
        
        // When
        Legislation legislation = Legislation.create(
            licenseTypeId, name, legislationType, null, null, null, createdBy, legislationTypeService
        );
        
        // Then
        assertThat(legislation.getName()).isEqualTo(name);
        assertThat(legislation.getLegislationType()).isEqualTo(legislationType);
        assertThat(legislation.getLicenseTypeId()).isEqualTo(licenseTypeId);
        assertThat(legislation.getStatus()).isEqualTo("ACTIVE");
        assertThat(legislation.getCreatedBy()).isEqualTo(createdBy);
        assertThat(legislation.hasDocument()).isFalse();
    }
    
    @Test
    void shouldThrowExceptionWhenNameIsEmpty() {
        // Given
        LicenseTypeId licenseTypeId = LicenseTypeId.generate();
        String emptyName = "";
        String legislationType = "LEI";
        String createdBy = "test-user";
        
        // When & Then
        assertThatThrownBy(() -> Legislation.create(
            licenseTypeId, emptyName, legislationType, null, null, null, createdBy, legislationTypeService
        )).isInstanceOf(DomainException.class)
          .hasMessage("Legislation name is required");
    }
    
    @Test
    void shouldAttachDocumentSuccessfully() {
        // Given
        Legislation legislation = createValidLegislation();
        String documentUrl = "http://minio.example.com/documents/test.pdf";
        String documentName = "test.pdf";
        String mimeType = "application/pdf";
        Long size = 1024L;
        String updatedBy = "test-user";
        
        // When
        legislation.attachDocument(documentUrl, documentName, mimeType, size, updatedBy);
        
        // Then
        assertThat(legislation.hasDocument()).isTrue();
        assertThat(legislation.getDocumentInfo().getUrl()).isEqualTo(documentUrl);
        assertThat(legislation.getDocumentInfo().getName()).isEqualTo(documentName);
        assertThat(legislation.getDocumentInfo().getMimeType()).isEqualTo(mimeType);
        assertThat(legislation.getDocumentInfo().getSize()).isEqualTo(size);
    }
    
    @Test
    void shouldValidateDocumentSizeLimit() {
        // Given
        Legislation legislation = createValidLegislation();
        Long oversizedDocument = 60L * 1024 * 1024; // 60MB
        
        // When & Then
        assertThatThrownBy(() -> legislation.attachDocument(
            "http://example.com/doc.pdf", "doc.pdf", "application/pdf", oversizedDocument, "user"
        )).isInstanceOf(DomainException.class)
          .hasMessage("Document size cannot exceed 50MB");
    }
    
    private Legislation createValidLegislation() {
        when(legislationTypeService.isValid("LEI")).thenReturn(true);
        return Legislation.create(
            LicenseTypeId.generate(), "Test", "LEI", null, null, null, "user", legislationTypeService
        );
    }
}

@ExtendWith(MockitoExtension.class)
class CreateLegislationUseCaseTest {
    
    @Mock
    private LegislationRepository legislationRepository;
    
    @Mock
    private LegislationDomainService domainService;
    
    @Mock
    private LegislationType legislationTypeService;
    
    @InjectMocks
    private CreateLegislationUseCase useCase;
    
    @Test
    void shouldCreateLegislationWithoutDocument() {
        // Given
        CreateLegislationCommand command = CreateLegislationCommand.builder()
            .licenseTypeId(LicenseTypeId.generate())
            .name("Test Legislation")
            .legislationType("LEI")
            .createdBy("test-user")
            .build();
        
        when(legislationTypeService.isValid("LEI")).thenReturn(true);
        when(legislationRepository.save(any(Legislation.class)))
            .thenAnswer(invocation -> invocation.getArgument(0));
        
        // When
        LegislationResponse response = useCase.execute(command);
        
        // Then
        assertThat(response.getName()).isEqualTo("Test Legislation");
        assertThat(response.getLegislationType()).isEqualTo("LEI");
        assertThat(response.getDocumentInfo()).isNull();
        
        verify(domainService).validateLicenseTypeExists(command.getLicenseTypeId());
        verify(domainService).validateUniqueNamePerLicenseType(
            command.getLicenseTypeId(), command.getName(), null
        );
        verify(legislationRepository).save(any(Legislation.class));
    }
}
```

### 6.2 Testes de Integração

```java
@SpringBootTest
@Transactional
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
class LegislationIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private LegislationRepository legislationRepository;
    
    @Autowired
    private LicenseTypeRepository licenseTypeRepository;
    
    @Test
    void shouldCreateLegislationViaAPI() {
        // Given
        LicenseType licenseType = createTestLicenseType();
        licenseTypeRepository.save(licenseType);
        
        CreateLegislationRequest request = new CreateLegislationRequest();
        request.setLicenseTypeId(licenseType.getId().getValue());
        request.setName("Test API Legislation");
        request.setLegislationType("LEI");
        request.setDescription("Test description");
        
        // When
        ResponseEntity<LegislationResponse> response = restTemplate.postForEntity(
            "/api/v1/legislations", request, LegislationResponse.class
        );
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(response.getBody().getName()).isEqualTo("Test API Legislation");
        
        // Verify in database
        Optional<Legislation> saved = legislationRepository.findById(
            LegislationId.of(response.getBody().getId())
        );
        assertThat(saved).isPresent();
        assertThat(saved.get().getName()).isEqualTo("Test API Legislation");
    }
    
    @Test
    void shouldListLegislationsByLicenseType() {
        // Given
        LicenseType licenseType = createTestLicenseType();
        licenseTypeRepository.save(licenseType);
        
        createTestLegislations(licenseType.getId(), 3);
        
        // When
        ResponseEntity<PageImpl> response = restTemplate.getForEntity(
            "/api/v1/legislations/license-type/" + licenseType.getId().getValue(),
            PageImpl.class
        );
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().getTotalElements()).isEqualTo(3);
    }
    
    private LicenseType createTestLicenseType() {
        return LicenseType.create(
            "Test License Type", "Description", SectorId.generate(), false, "NORMAL", "test-user"
        );
    }
    
    private void createTestLegislations(LicenseTypeId licenseTypeId, int count) {
        for (int i = 1; i <= count; i++) {
            Legislation legislation = Legislation.create(
                licenseTypeId,
                "Test Legislation " + i,
                "LEI",
                null, null, null,
                "test-user",
                new LegislationType(null) {
                    @Override
                    public boolean isValid(String value) {
                        return true;
                    }
                }
            );
            legislationRepository.save(legislation);
        }
    }
}
```

## 7. Monitorização e Métricas

### 7.1 Métricas de Performance

```java
@Component
public class LegislationMetrics {
    
    private final MeterRegistry meterRegistry;
    private final Counter legislationCreatedCounter;
    private final Counter legislationUpdatedCounter;
    private final Counter legislationDeletedCounter;
    private final Counter documentUploadCounter;
    private final Timer legislationQueryTimer;
    
    public LegislationMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.legislationCreatedCounter = Counter.builder("legislation.created")
            .description("Number of legislations created")
            .register(meterRegistry);
        this.legislationUpdatedCounter = Counter.builder("legislation.updated")
            .description("Number of legislations updated")
            .register(meterRegistry);
        this.legislationDeletedCounter = Counter.builder("legislation.deleted")
            .description("Number of legislations deleted")
            .register(meterRegistry);
        this.documentUploadCounter = Counter.builder("legislation.document.uploaded")
            .description("Number of documents uploaded")
            .register(meterRegistry);
        this.legislationQueryTimer = Timer.builder("legislation.query")
            .description("Time taken to query legislations")
            .register(meterRegistry);
    }
    
    public void incrementCreated() {
        legislationCreatedCounter.increment();
    }
    
    public void incrementUpdated() {
        legislationUpdatedCounter.increment();
    }
    
    public void incrementDeleted(int count) {
        legislationDeletedCounter.increment(count);
    }
    
    public void incrementDocumentUploaded() {
        documentUploadCounter.increment();
    }
    
    public Timer.Sample startQueryTimer() {
        return Timer.start(meterRegistry);
    }
    
    public void recordQueryTime(Timer.Sample sample) {
        sample.stop(legislationQueryTimer);
    }
}
```

### 7.2 Health Checks

```java
@Component
public class LegislationHealthIndicator implements HealthIndicator {
    
    private final LegislationRepository legislationRepository;
    private final DocumentStorageService documentStorageService;
    
    @Override
    public Health health() {
        try {
            // Verificar conectividade com base de dados
            long count = legislationRepository.count();
            
            // Verificar conectividade com Minio
            boolean minioHealthy = checkMinioHealth();
            
            if (minioHealthy) {
                return Health.up()
                    .withDetail("database", "UP")
                    .withDetail("minio", "UP")
                    .withDetail("legislation_count", count)
                    .build();
            } else {
                return Health.down()
                    .withDetail("database", "UP")
                    .withDetail("minio", "DOWN")
                    .withDetail("legislation_count", count)
                    .build();
            }
        } catch (Exception e) {
            return Health.down()
                .withDetail("database", "DOWN")
                .withDetail("error", e.getMessage())
                .build();
        }
    }
    
    private boolean checkMinioHealth() {
        try {
            // Tentar verificar se o serviço Minio está acessível
            return documentStorageService.fileExists("health-check-dummy-file");
        } catch (Exception e) {
            return false;
        }
    }
}
```

## 8. Configuração de Segurança

### 8.1 Permissões de Acesso

```sql
-- Permissões para tabela t_legislation
GRANT SELECT ON t_legislation TO anon;
GRANT ALL PRIVILEGES ON t_legislation TO authenticated;

-- RLS (Row Level Security) para legislações
ALTER TABLE t_legislation ENABLE ROW LEVEL SECURITY;

-- Política para usuários autenticados verem todas as legislações ativas
CREATE POLICY legislation_select_policy ON t_legislation
    FOR SELECT
    TO authenticated
    USING (status = 'ACTIVE');

-- Política para usuários anônimos verem apenas legislações ativas
CREATE POLICY legislation_anon_select_policy ON t_legislation
    FOR SELECT
    TO anon
    USING (status = 'ACTIVE');

-- Política para inserção/atualização apenas por usuários autenticados
CREATE POLICY legislation_modify_policy ON t_legislation
    FOR ALL
    TO authenticated
    USING (true)
    WITH CHECK (true);
```

## 9. Conclusão

Este documento especifica a implementação completa do módulo de **Gestão de Legislações** para o Sistema de Licenciamento de Cabo Verde, incluindo:

### 9.1 Funcionalidades Implementadas

* ✅ **Normalização de Dados**: Migração de `GLIC_T_LEGISLACAO` para `T_LEGISLATION`

* ✅ **Arquitetura DDD**: Implementação completa com entidades, value objects e serviços

* ✅ **APIs REST**: Endpoints para CRUD com filtros avançados

* ✅ **Armazenamento de Documentos**: Integração com Minio substituindo `REDGLOBAL.GLB_T_DOCUMENT`

* ✅ **Validações Robustas**: Validações de negócio e integridade referencial

* ✅ **Integração com T\_OPTIONS**: Tipos de legislação parametrizáveis

* ✅ **Testes Abrangentes**: Testes unitários e de integração

* ✅ **Monitorização**: Métricas de performance e health checks

* ✅ **Segurança**: Controle de acesso e auditoria

### 9.2 Benefícios da Implementação

* **Flexibilidade**: Tipos de legislação configuráveis via `T_OPTIONS`

* **Escalabilidade**: Arquitetura preparada para crescimento

* **Manutenibilidade**: Código limpo seguindo princípios DDD

* **Performance**: Índices otimizados e cache de consultas

* **Segurança**: Controle de acesso granular e auditoria completa

* **Usabilidade**: APIs intuitivas com filtros e paginação

### 9.3 Próximos Passos

1. **Implementação**: Desenvolver o código seguindo as especificações
2. **Testes**: Executar testes unitários e de integração
3. **Deploy**: Aplicar migrações e configurar ambiente
4. **Monitorização**: Configurar alertas e dashboards
5. **Documentação**: Atualizar documentação de usuário

O módulo está pronto para implementação e integração com o sistema existente, mantendo compatibilidade e oferecendo funcionalidades avançadas para gestão de legislações.

```
```

